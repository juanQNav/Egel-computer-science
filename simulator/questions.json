[
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "¿Cuál es la característica fundamental que define la necesidad de utilizar un registro o estructura (struct) en lugar de una matriz (array)?",
    "opciones": {
      "A": "La capacidad de almacenar datos en posiciones de memoria no contiguas.",
      "B": "La posibilidad de que los elementos o campos almacenados sean de tipos de datos diferentes.",
      "C": "La restricción de que el acceso a los datos se realiza únicamente mediante notación de punto."
    },
    "respuesta_correcta": "B",
    "justificacion": "Un registro o estructura es una colección heterogénea de elementos, permitiendo almacenar datos de diferente tipo en una sola variable, a diferencia de una matriz, que requiere que todos los elementos sean del mismo tipo."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "En el contexto de las estructuras de datos, ¿qué principio de operación rige a una Pila (Stack)?",
    "opciones": {
      "A": "FIFO (First In, First Out).",
      "B": "LIFO (Last In, First Out).",
      "C": "FEFO (First Executed, First Out)."
    },
    "respuesta_correcta": "B",
    "justificacion": "Una Pila es una clase de lista donde el último elemento en ser añadido es el primero en ser retirado. Este comportamiento es conocido como LIFO."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Si se declara una variable de tipo registro llamada `CLIENTE` con un campo llamado `nombre`, ¿cuál es la sintaxis correcta para acceder y manipular el valor del campo `nombre`?",
    "opciones": {
      "A": "`CLIENTE -> nombre`",
      "B": "`nombre[CLIENTE]`",
      "C": "`CLIENTE.nombre`"
    },
    "respuesta_correcta": "C",
    "justificacion": "Para acceder a un campo de una variable tipo registro, se utiliza la notación de punto, siguiendo la sintaxis `variable_registro.id_campo`."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "¿Cómo se denomina a los datos individuales (caracteres, números enteros, o de coma flotante) que conforman un registro o estructura?",
    "opciones": {
      "A": "Celdas o índices.",
      "B": "Campos, elementos o miembros.",
      "C": "Vectores o tuplas."
    },
    "respuesta_correcta": "B",
    "justificacion": "A los datos del registro se les denomina campos, elementos o miembros."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Se requiere modelar la información de un acreedor que incluye su `nombre` (cadena de caracteres) y su `dirección`, donde la `dirección` está compuesta por `calle` (cadena) y `número` (entero). ¿Cuál es la estructura de acceso correcta para obtener el `número` del acreedor, asumiendo que el registro `ACREEDOR` tiene un campo `dirección` de tipo `DOMICILIO`?",
    "opciones": {
      "A": "`ACREEDOR.DOMICILIO.número`",
      "B": "`ACREEDOR.dirección.número`",
      "C": "`ACREEDOR->dirección->número`"
    },
    "respuesta_correcta": "B",
    "justificacion": "Para acceder a los campos de un registro anidado, se debe utilizar la sintaxis `variable_registro.id_campo1.id_campo2`, donde `dirección` es el campo intermedio y `número` es el campo final al que se desea acceder."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Un desarrollador utiliza punteros para implementar una lista de registros. Si un puntero no apunta a ningún registro, ¿qué valor especial se le asigna típicamente?",
    "opciones": {
      "A": "`Void`",
      "B": "`Zero`",
      "C": "`Nil`"
    },
    "respuesta_correcta": "C",
    "justificacion": "Un puntero tiene el valor especial `nil` (o nulo) si no apunta a ningún registro, lo cual es común al inicio o al final de las listas."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "¿Cuál es la condición indispensable para que el concepto de recursividad pueda ser aplicado exitosamente en el diseño de un algoritmo?",
    "opciones": {
      "A": "Que la función se declare como un procedimiento.",
      "B": "Que exista una condición previamente definida para finalizar la llamada a sí misma.",
      "C": "Que la función utilice punteros para la autoinvocación."
    },
    "respuesta_correcta": "B",
    "justificacion": "La recursividad es cuando una función se llama a sí misma, y para finalizarla debe existir una condición previamente definida."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Una compañía necesita almacenar datos complejos y heterogéneos para cada uno de sus empleados (Nombre, Dirección, Edad, Sexo, Antigüedad). ¿Por qué no es posible usar un arreglo (matriz) para esta tarea?",
    "opciones": {
      "A": "Porque el tamaño del arreglo no se puede determinar de antemano.",
      "B": "Porque los componentes de un arreglo deben ser todos del mismo tipo.",
      "C": "Porque los arreglos no permiten el uso de notación de punto para acceder a sus elementos."
    },
    "respuesta_correcta": "B",
    "justificacion": "Si se desea almacenar datos de diferente tipo (cadenas, enteros, caracteres) no es posible usar un arreglo, ya que sus componentes deben ser todos del mismo tipo."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Un registro o estructura es un tipo de dato **_________** y definido por el usuario que permite almacenar datos de **_________** tipo en una sola variable.\nEl/Los elemento(s) que completa(n) correctamente el planteamiento es/son...",
    "opciones": {
      "A": "simple / único",
      "B": "estructurado / diferente",
      "C": "primitivo / el mismo"
    },
    "respuesta_correcta": "B",
    "justificacion": "Un registro es un tipo de dato _estructurado_ que permite almacenar datos de _diferente_ tipo. Es la base de las estructuras heterogéneas."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Si se añaden cuatro documentos (A, B, C, D) a una Pila en ese orden, y luego se retiran dos documentos, los primeros en salir serán **_______** siguiendo el principio **_______**.",
    "opciones": {
      "A": "A y B / FIFO",
      "B": "C y D / LIFO",
      "C": "D y C / LIFO"
    },
    "respuesta_correcta": "C",
    "justificacion": "El principio LIFO (Last In, First Out) dicta que el último elemento en entrar (D) es el primero en salir, seguido por el penúltimo (C)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "En la terminología de estructuras de datos, a los elementos que componen un registro, los cuales pueden ser de tipo simple o compuesto, se les denomina comúnmente **_______**, **_______** o **_______**.",
    "opciones": {
      "A": "celdas, filas, columnas",
      "B": "campos, elementos, miembros",
      "C": "punteros, referencias, nodos"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los datos que componen un registro se denominan campos, elementos o miembros."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "La sintaxis en pseudocódigo para definir un registro típicamente inicia con `registro ident_registro inicio`, mientras que la sintaxis equivalente en lenguaje C es `struct ident_registro ______________`.",
    "opciones": {
      "A": "`public:`",
      "B": "`(`",
      "C": "`{`"
    },
    "respuesta_correcta": "C",
    "justificacion": "Según la correspondencia entre pseudocódigo y lenguaje C para la definición de un registro, la palabra clave `inicio` se traduce en el corchete de apertura `{` en C."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Para implementar una lista de registros que pueden ser creados y destruidos de forma dinámica en tiempo de ejecución, se recomienda el uso de **_______** en conjunción con los registros. Cuando la lista está vacía, el elemento que indica la ausencia de un registro se representa con el valor especial **_______**.",
    "opciones": {
      "A": "funciones / `NULL_PTR`",
      "B": "punteros / `nil`",
      "C": "índices / `0`"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los punteros se utilizan con registros para crear/destruir registros dinámicamente, y `nil` es el valor especial para indicar que un puntero no apunta a ningún registro."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Para acceder a un campo de un registro que a su vez es un arreglo (por ejemplo, el campo `saldos` que es un arreglo de reales dentro de un registro `CLIENTE`), se debe utilizar la sintaxis que combina la notación de punto para el campo de registro con la notación de corchetes para el índice: `variable_registro.campo_arreglo[índice]`. Si se desea acceder al saldo del mes 5 del cliente `mi_cliente`, la sintaxis sería `mi_cliente.saldos[5]`. Si el campo `saldos` fuera a su vez un registro llamado `info_saldos` que contiene el arreglo, la sintaxis correcta para acceder al mes 5 sería `mi_cliente.info_saldos.saldos[5]`. Asumiendo que el campo `saldos` es directamente un arreglo, la sintaxis de acceso al mes 12 es:",
    "opciones": {
      "A": "`mi_cliente.saldos.12`",
      "B": "`mi_cliente.saldos`",
      "C": "`mi_cliente.saldos[12]`"
    },
    "respuesta_correcta": "C",
    "justificacion": "Se accede primero al campo `saldos` del registro `mi_cliente` utilizando la notación de punto, y luego se indexa el arreglo con corchetes para obtener el valor del mes 12: `variable_registro.campo_arreglo[índice]`."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "La definición del registro `CLIENTE` incluye los campos `nombre` (cadena), `teléfono` (cadena), `saldos` y `moroso` (booleano). Para almacenar los saldos mensuales del último año (12 reales), el campo `saldos` debe definirse como un **_______**.",
    "opciones": {
      "A": "registro `FECHA`",
      "B": "arreglo `[1..12] DE reales`",
      "C": "lista enlazada `DE reales`"
    },
    "respuesta_correcta": "B",
    "justificacion": "El campo `saldos` es una colección de elementos del mismo tipo (reales), idealmente definidos como un arreglo unidimensional de tamaño 12 (ej. `ARREGLO [1..12] DE reales`)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Una matriz es una estructura de datos que consta de un número fijo de ítems del mismo tipo, cuyos elementos suelen almacenarse en **_______** contiguas de **_______**.",
    "opciones": {
      "A": "ubicaciones / registros",
      "B": "posiciones / almacenamiento",
      "C": "funciones / la variable"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los elementos de una matriz suelen almacenarse en _posiciones_ contiguas de _almacenamiento_."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione el tipo de estructura de datos con su característica definitoria.\n**[Estructura]**\n1. Matriz (Arreglo)\n2. Registro (Estructura)\n3. Pila\n**[Característica]**\na) Colección de campos relacionados de tipos de datos diferentes.\nb) Principio de funcionamiento LIFO (Last In, First Out).\nc) Colección de ítems que deben ser todos del mismo tipo.",
    "opciones": {
      "A": "1-a, 2-c, 3-b",
      "B": "1-b, 2-a, 3-c",
      "C": "1-c, 2-a, 3-b"
    },
    "respuesta_correcta": "C",
    "justificacion": "Una Matriz consta de ítems del mismo tipo (1-c). Un Registro almacena campos de diferente tipo (2-a). Una Pila opera bajo el principio LIFO (3-b)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione el concepto fundamental con su descripción clave.\n**[Concepto]**\n1. Recursividad\n2. Punteros\n3. Campo\n**[Descripción Clave]**\na) Mecanismo esencial para la creación y destrucción dinámica de registros en estructuras de listas.\nb) Parte de un registro al que se tiene acceso mediante la notación de punto.\nc) Técnica algorítmica que requiere una condición predefinida para su finalización.",
    "opciones": {
      "A": "1-c, 2-a, 3-b",
      "B": "1-a, 2-c, 3-b",
      "C": "1-c, 2-b, 3-a"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Recursividad debe tener una condición para finalizar (1-c). Los Punteros se usan para manejar registros dinámicamente (2-a). El Campo es un dato dentro del registro (3-b)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Una compañía define un registro `CLIENTE` con varios campos. Relacione el tipo de dato requerido con el concepto de campo.\n**[Tipo de Dato Requerido]**\n1. Dato único y heterogéneo (ej. Edad)\n2. Colección de datos homogéneos (ej. Saldos mensuales)\n3. Dato complejo heterogéneo (ej. Dirección que incluye calle, número, ciudad)\n**[Concepto de Campo]**\na) Campo que debe ser de tipo Estructura o Registro anidado.\nb) Campo que debe ser de tipo Matriz o Arreglo unidimensional.\nc) Campo que debe ser de tipo Entero simple.",
    "opciones": {
      "A": "1-c, 2-b, 3-a",
      "B": "1-a, 2-b, 3-c",
      "C": "1-c, 2-a, 3-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Edad es un tipo simple (1-c). Los Saldos son homogéneos y recurrentes, ideales para un Arreglo (2-b). La Dirección compleja es un Registro dentro de otro (anidado) (3-a)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione la estructura de datos con su concepto de definición en el contexto de la programación.\n**[Concepto]**\n1. Estructura (Struct)\n2. Lista\n3. Matriz\n**[Definición]**\na) Colección de ítems cuyo acceso se realiza mediante un índice numérico para un elemento específico.\nb) Colección ordenada de elementos que, en implementaciones dinámicas, suele requerir el uso de punteros.\nc) Colección de datos donde no es necesario establecer un orden entre los componentes ni la homogeneidad de tipos.",
    "opciones": {
      "A": "1-c, 2-b, 3-a",
      "B": "1-a, 2-c, 3-b",
      "C": "1-b, 2-a, 3-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Estructura no requiere orden ni homogeneidad (1-c). Una Lista es una colección ordenada que a menudo usa punteros (2-b). El acceso a una Matriz se realiza por índice (3-a)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione la palabra clave utilizada en la definición de registros con el contexto de programación al que corresponde.\n**[Contexto]**\n1. Pseudocódigo\n2. Lenguaje C\n**[Palabra/Símbolo]**\na) `struct`\nb) `registro`\nc) `{`\nd) `fin`",
    "opciones": {
      "A": "1-a,d; 2-b,c",
      "B": "1-b,d; 2-a,c",
      "C": "1-c,a; 2-b,d"
    },
    "respuesta_correcta": "B",
    "justificacion": "En Pseudocódigo, se usan `registro` y `fin`. En Lenguaje C, se usan `struct` y `{` para iniciar la definición."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione el desafío de la estructura de datos con el mecanismo o principio que resuelve el problema.\n**[Desafío/Problema]**\n1. Acceder al código de la carrera en un registro `ESTUDIANTE` que contiene campos anidados.\n2. Almacenar datos complejos de diferente tipo (Nombre, Dirección, Edad) para un objeto.\n3. Garantizar que un algoritmo de autoinvocación (recursividad) no corra indefinidamente.\n4. Simular la extracción de elementos en el orden inverso al que fueron introducidos.\n**[Mecanismo/Principio Solución]**\na) Principio LIFO.\nb) Definición de una condición de finalización.\nc) Uso de un Registro o Estructura.\nd) Sintaxis de acceso con punto anidado (`reg.campo1.campo2`).",
    "opciones": {
      "A": "1-d, 2-c, 3-b, 4-a",
      "B": "1-c, 2-d, 3-a, 4-b",
      "C": "1-d, 2-c, 3-a, 4-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "El acceso a campos anidados se logra con notación de punto anidada (1-d). Los datos heterogéneos requieren un Registro (2-c). La recursividad debe tener una condición de finalización (3-b). La simulación de orden inverso (el último entra, el primero sale) es el principio LIFO de la Pila (4-a)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione las siguientes operaciones de estructura de datos con el elemento subyacente que las facilita o requiere.\n**[Operación Requerida]**\n1. Determinar el fin de una secuencia de elementos en una lista implementada dinámicamente.\n2. Almacenar los datos de un cliente (nombre, saldo, teléfono) en una sola variable.\n3. Trasladar un elemento a la memoria local en un proceso de carga colaborativa (en cómputo paralelo).\n**[Elemento Estructural Subyacente]**\na) Un campo tipo Arreglo para la colección de datos.\nb) Un puntero con valor `nil`.\nc) Una estructura de tipo Registro.",
    "opciones": {
      "A": "1-b, 2-c, 3-a",
      "B": "1-a, 2-c, 3-b",
      "C": "1-b, 2-a, 3-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "El fin de una lista dinámica se marca con un puntero `nil` (1-b). Los datos heterogéneos de un cliente se modelan con un Registro (2-c). La carga colaborativa de datos tabulares (matrices) se realiza elemento por elemento (ej. `c5,2` de A y B) (3-a)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione la sintaxis de acceso con el tipo de estructura o implementación que le corresponde.\n**[Sintaxis de Acceso]**\n1. `variable_registro.id_campo`\n2. `variable_registro.id_campo1.id_campo2`\n3. `nombre_arreglo[i][j]`\n**[Estructura o Implementación]**\na) Matriz multidimensional.\nb) Registro con campos anidados.\nc) Registro simple.",
    "opciones": {
      "A": "1-c, 2-b, 3-a",
      "B": "1-b, 2-c, 3-a",
      "C": "1-a, 2-b, 3-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "La sintaxis de acceso por punto simple es para registros sin anidamiento (1-c). El punto anidado es para registros dentro de registros (2-b). El acceso con múltiples corchetes es típico de una Matriz multidimensional (3-a)."
  },
  {
    "tema": "Algoritmia - Estructuras de datos",
    "pregunta": "Relacione el uso de estructuras con la flexibilidad y el propósito que ofrecen.\n**[Uso o Propósito]**\n1. Almacenamiento de elementos en memoria contigua, accediendo por índice.\n2. Permitir que una función se repita, siempre que exista un mecanismo de parada.\n3. Definir un tipo de dato que contiene campos de diferente naturaleza.\n**[Estructura o Concepto]**\na) Recursividad.\nb) Matriz.\nc) Registro.",
    "opciones": {
      "A": "1-b, 2-a, 3-c",
      "B": "1-c, 2-b, 3-a",
      "C": "1-a, 2-c, 3-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Matriz permite el almacenamiento contiguo y el acceso por índice (1-b). La Recursividad implica la repetición o autoinvocación controlada por una condición de parada (2-a). El Registro se define para contener datos heterogéneos (3-c)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "¿Cuál de los siguientes es un componente fundamental de la definición formal de un Autómata Finito (FA)?",
    "opciones": {
      "A": "Un conjunto de reglas de movimiento, estado inicial y una cinta infinita de memoria.",
      "B": "Un alfabeto de entrada, un conjunto de estados y un conjunto de estados de aceptación.",
      "C": "Un alfabeto de entrada, un número $n$ de cintas y un conjunto de estados de aceptación."
    },
    "respuesta_correcta": "B",
    "justificacion": "Un Autómata Finito se define formalmente como una 5-tupla, la cual incluye un conjunto de estados, un alfabeto de entrada, reglas para moverse, un estado inicial y un conjunto de estados de aceptación. La opción A es incorrecta porque la cinta infinita es característica de la Máquina de Turing. La opción C es incorrecta, ya que la definición de un FA no especifica un número $n$ de cintas."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "En el contexto del Álgebra de Boole utilizada en la lógica computacional, ¿cómo se interpreta generalmente el elemento $0$?",
    "opciones": {
      "A": "Señal de Salida.",
      "B": "Falso.",
      "C": "Sí."
    },
    "respuesta_correcta": "B",
    "justificacion": "En campos como la informática y la lógica matemática, los dos elementos del sistema (0 y 1) se interpretan como \"VERDADERO-FALSO\" o \"SEÑAL-NO SEÑAL\". Por convención, 0 representa FALSE (Falso)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Si se utiliza la Lógica de Primer Orden (FOL) para representar categorías, ¿cuál de las siguientes opciones describe el método de **reificación**?",
    "opciones": {
      "A": "Utilizar un predicado para asignar una propiedad al objeto, como $Basketball(b)$.",
      "B": "Utilizar un conjunto de axiomas para definir las propiedades intrínsecas del objeto.",
      "C": "Tratar la categoría como un objeto en sí mismo, como $Basketballs$."
    },
    "respuesta_correcta": "C",
    "justificacion": "La reificación es una de las dos opciones para representar categorías en la Lógica de Primer Orden, donde la categoría se trata como un objeto, y la pertenencia se indica con la notación $b \\in Basketballs$. La opción A describe el uso de predicados, el método alternativo."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "¿Qué estructura de gramática se requiere para que el algoritmo CYK (Cocke-Younger-Kasami) pueda procesar una cadena de símbolos?",
    "opciones": {
      "A": "Gramática Independiente del Contexto (GIC).",
      "B": "Gramática Regular.",
      "C": "Chomsky Normal Form."
    },
    "respuesta_correcta": "C",
    "justificacion": "El algoritmo CYK requiere que la gramática tenga todas sus reglas en una de dos formas muy específicas (lexical: $X \\rightarrow \\textbf{word}$ o sintáctica: $X \\rightarrow YZ$), que juntas definen el **Chomsky Normal Form**."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Un problema de $N$-cuerpos produce un sistema de $6N$ ecuaciones diferenciales. ¿Por qué es necesaria la **computación paralela** para resolver este tipo de problemas en la práctica?",
    "opciones": {
      "A": "Porque el tiempo de ejecución del algoritmo secuencial es polilogarítmico en $N$, lo cual es muy lento.",
      "B": "Porque los valores de $N$ son generalmente demasiado grandes, haciendo que los métodos numéricos para uniprocesador no sean prácticos.",
      "C": "Porque solo se conoce un algoritmo de tiempo exponencial para la solución, lo que exige distribuir la carga."
    },
    "respuesta_correcta": "B",
    "justificacion": "En la práctica, los valores de $N$ son a menudo _demasiado grandes_ para que los métodos numéricos convencionales programados para computadoras de uniprocesador sean de valor práctico. La solución implica utilizar una **computadora paralela** para que sus múltiples procesadores colaboren."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Si un problema $P$ se clasifica como $TOTAL \\in \\Pi_2^0$ y otro problema $Q$ es $\\le_m$-completo para $\\Sigma_1^0$ ($HP$ - Halting Problem). ¿Qué se puede inferir sobre la reducibilidad de $P$ a $Q$?",
    "opciones": {
      "A": "$P$ sí se puede reducir a $Q$ porque $\\Pi_2^0$ es una clase de mayor complejidad que $\\Sigma_1^0$.",
      "B": "$P$ no se puede reducir a $Q$ porque la jerarquía colapsaría al nivel inferior de $Q$.",
      "C": "$P$ sí se puede reducir a $Q$ si se utiliza una Máquina de Turing de una sola dirección."
    },
    "respuesta_correcta": "B",
    "justificacion": "Dado que la jerarquía de complejidad es estricta, un problema no está contenido en ninguna clase inferior de la jerarquía ni se $\\le_T$-reduce a ningún problema completo para una clase inferior. Si $P$ (en $\\Pi_2^0$) redujera a $Q$ (en $\\Sigma_1^0$), la jerarquía colapsaría."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "¿Cuál es la principal razón por la que el **Problema del Vendedor Viajero (TSP)** se considera un desafío en la clasificación de complejidad, cayendo en la tercera categoría de problemas?",
    "opciones": {
      "A": "Ha sido probado como intratable, similar a la Aritmética de Presburger.",
      "B": "Aún no se ha encontrado un algoritmo de tiempo polinómico, pero tampoco se ha probado que uno sea imposible.",
      "C": "Se sabe que pertenece a la clase $P$, pero los algoritmos existentes tienen constantes muy grandes."
    },
    "respuesta_correcta": "B",
    "justificacion": "El TSP cae en la tercera categoría de problemas: aquellos que no han sido probados como intratables, pero para los cuales **nunca se han encontrado algoritmos de tiempo polinómico**. Se han encontrado algoritmos (como _branch-and-bound_ y _backtracking_) eficientes para muchas instancias grandes, pero no para el conjunto infinito de todas las instancias."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Un algoritmo paralelo logra un tiempo de ejecución de $O(\\log^2 n)$. Según la teoría de complejidad, ¿cómo se clasifica este rendimiento en términos de velocidad?",
    "opciones": {
      "A": "Exponencialmente rápido, superando las limitaciones de $NP$.",
      "B": "Polinomialmente lento, indicando una necesidad de más procesadores.",
      "C": "Rápido, ya que su tiempo de ejecución es polilogarítmico en $n$."
    },
    "respuesta_correcta": "C",
    "justificacion": "Un algoritmo paralelo se considera **rápido** si su tiempo de ejecución paralelo es **polilogarítmico** en $n$. $O(\\log^2 n)$ es una función polilogarítmica, indicando un rendimiento rápido."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "La definición de los estados de un Autómata Finito No Determinista (NFA) $M'$ se basa en **triples ordenados** de elementos de $Q$, donde el primer componente modela la posición del **_______**, el segundo componente modela la posición del **_______**, y el tercero modela la posición del **_______**.\nEl/Los elemento(s) que completa(n) correctamente el planteamiento es/son...",
    "opciones": {
      "A": "guijarro azul, guijarro blanco, guijarro verde.",
      "B": "guijarro blanco, guijarro verde, guijarro azul.",
      "C": "guijarro verde, guijarro azul, guijarro blanco."
    },
    "respuesta_correcta": "B",
    "justificacion": "Para un NFA $M'$, la definición formal establece que el primer componente del triple $(p, q, r)$ modela la posición del guijarro **blanco** (white pebble), el segundo la del guijarro **verde** (green pebble), y el tercero la del guijarro **azul** (blue pebble)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "El concepto que describe la dificultad de un problema basándose en el crecimiento exponencial del tiempo de solución con respecto al tamaño de la instancia se conoce como **_______**.",
    "opciones": {
      "A": "Complejidad Asintótica.",
      "B": "Intractabilidad.",
      "C": "Polinomialidad."
    },
    "respuesta_correcta": "B",
    "justificacion": "Un problema se denomina **intratable** si el tiempo requerido para resolver sus instancias crece exponencialmente con el tamaño de las instancias. La intratabilidad implica que incluso instancias moderadamente grandes no se pueden resolver en un tiempo razonable."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "En el modelado de lenguajes formales, la **_______** se refiere a un patrón, no a un conjunto de cadenas, pero a menudo se utiliza de forma abreviada para representar $L(a^*b^*)$ como $a^*b^*$.",
    "opciones": {
      "A": "Gramática libre de contexto.",
      "B": "Expresión regular.",
      "C": "Producción terminal."
    },
    "respuesta_correcta": "B",
    "justificacion": "Estrictamente, $a^*b^*$ es un patrón y no un conjunto de cadenas, por lo que se debería escribir $x \\in L(a^*b^*)$. Sin embargo, es aceptable escribir $x \\in a^*b^*$ como una abreviatura, lo que se refiere a las **expresiones regulares**. Las expresiones regulares están definidas por un autómata de estado finito."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "El proceso que utiliza un conjunto de oraciones lógicas (hechos y axiomas) para obtener una conclusión o una respuesta a una pregunta se denomina **_______**.",
    "opciones": {
      "A": "Reificación.",
      "B": "Saturación.",
      "C": "Resolución."
    },
    "respuesta_correcta": "C",
    "justificacion": "El proceso para generar una respuesta en lógica se logra cuando se genera una cláusula que contiene solo un literal de respuesta única a través del proceso de **resolución**. La inferencia es un proceso central en este tipo de problemas."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "El **_______** es un problema indecidible que se define por una colección de \"dominós,\" cada uno con dos cadenas, donde la tarea es listarlos (con repeticiones permitidas) para que la cadena superior sea idéntica a la cadena inferior.",
    "opciones": {
      "A": "Problema de Correspondencia de Post (PCP).",
      "B": "Problema del Vendedor Viajero (TSP).",
      "C": "Problema de Satisfacibilidad (SAT)."
    },
    "respuesta_correcta": "A",
    "justificacion": "El **Problema de Correspondencia de Post (PCP)** es un problema sobre manipulación de cadenas que ha sido demostrado ser indecidible. Se utilizan para demostrar la indecidibilidad de otros problemas."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "La noción lógica que expresa que un conjunto de elementos no tiene miembros en común se denomina **_______**, mientras que la noción de que todos los elementos de un superconjunto están cubiertos por las subcategorías se llama **_______**.",
    "opciones": {
      "A": "Disyunción, Clausura.",
      "B": "Disjoint, Exhaustive Decomposition.",
      "C": "Mutuamente Excluyente, Completion."
    },
    "respuesta_correcta": "B",
    "justificacion": "Dos o más categorías son **disjoint** si no tienen miembros en común. Para saber que un elemento no en una categoría debe estar en otra, se requiere que constituyan una **exhaustive decomposition** del superconjunto (como animales, divididos en machos y hembras)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Para resolver el problema clásico de $n$-cuerpos, si se utiliza un sistema de $6n$ ecuaciones diferenciales, el número de **unidades de procesamiento** $p$ en una arquitectura paralela debe ser una función **_______** de $n$, idealmente de bajo grado (como 2, 3 o 4).",
    "opciones": {
      "A": "logarítmica.",
      "B": "exponencial.",
      "C": "polinómica."
    },
    "respuesta_correcta": "C",
    "justificacion": "El número de unidades de procesamiento $p$ debe ser alguna función **polinómica** $poly(n)$ de $n$. Se descartan funciones polinómicas de grados \"irrazonablemente\" grandes (como $n^{100}$), esperando grados bajos como 2, 3, o 4."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Según la teoría de la complejidad, un problema para el cual se ha probado que un algoritmo de tiempo polinómico es imposible se considera generalmente de la clase **_______**.",
    "opciones": {
      "A": "P.",
      "B": "NP.",
      "C": "Intratable."
    },
    "respuesta_correcta": "C",
    "justificacion": "Los problemas para los cuales se ha probado que los algoritmos de tiempo polinómico son imposibles se consideran **intratables**. Estos problemas (como la Aritmética de Presburger o el Problema de la Parada) también han sido probados como fuera de la clase $NP$."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione el concepto fundamental de la Máquina de Turing con el elemento que representa en el modelo formal.\n**Concepto**\n1. Programa\n2. Cinta unidimensional\n3. Cabezal de lectura/escritura\n4. Acción de la máquina\n**Elemento Representado**\na) El mapeo que determina las acciones permitidas por el estado y el símbolo.\nb) Unidad que puede escribir un símbolo, hacer transición de estado o moverse.\nc) Almacena un símbolo en cada celda a lo largo de su longitud.\nd) La meta de controlar la máquina para entrar al estado de aceptación.",
    "opciones": {
      "A": "1a, 2c, 3b, 4d",
      "B": "1c, 2a, 3b, 4d",
      "C": "1a, 2b, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "El programa de la TM es el mapeo que determina las acciones permitidas (1a). La cinta unidimensional consiste en celdas, cada una conteniendo un símbolo (2c). El cabezal de lectura/escritura realiza las acciones (3b). La meta de controlar la máquina para entrar al estado de aceptación es el objetivo final (4d)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione los componentes del Álgebra de Boole con las interpretaciones del mundo real utilizadas en la lógica computacional.\n**Componente Lógico**\n1. Elemento 1\n2. Elemento 0\n3. Operación $\\cdot$ (AND)\n4. Operación $\\oplus$ (XOR)\n**Interpretación / Uso**\na) FALSO / NO SEÑAL.\nb) VERDADERO / SEÑAL.\nc) Función utilizada para determinar si una compuerta debe dividir la operación.\nd) Representación de la conjunción (\"A and B\").\ne) Representación de la disyunción exclusiva.",
    "opciones": {
      "A": "1b, 2a, 3d, 4e",
      "B": "1a, 2b, 3e, 4d",
      "C": "1b, 2a, 3e, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "El elemento 1 se interpreta como VERDADERO / SEÑAL (1b). El elemento 0 se interpreta como FALSO / NO SEÑAL (2a). $\\cdot$ (AND) representa la conjunción (3d). $\\oplus$ (XOR) representa la disyunción exclusiva (4e)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione la clase de problema con la categoría de complejidad a la que pertenece o con un hecho relevante sobre su solución.\n**Clase de Problema**\n1. Problemas en la clase $P$\n2. Problemas del Vendedor Viajero (TSP)\n3. Aritmética de Presburger\n4. Problemas en $NP$\n**Categoría de Complejidad**\na) Problema que ha sido probado como intratable (no está en $NP$).\nb) Problemas para los cuales se han encontrado algoritmos de tiempo polinómico.\nc) Problemas que tienen una solución de tiempo polinómico si $P=NP$.\nd) Problemas que no han sido probados como intratables, pero para los que no hay algoritmo polinómico conocido para todas las instancias.\ne) Problemas decidibles, pero que requieren tiempo exponencial para su solución.",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1b, 2d, 3a, 4c",
      "C": "1b, 2a, 3d, 4e"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los problemas en $P$ son aquellos para los que se han encontrado algoritmos de tiempo polinómico (1b). El TSP no ha sido probado como intratable, pero carece de un algoritmo polinómico general (2d). La Aritmética de Presburger es un problema que ha sido probado como intratable y no está en $NP$ (3a). La mayoría de los problemas en $NP$ tendrían algoritmos de tiempo polinómico si $P=NP$ (4c)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione el tipo de concepto lógico con su función en la estructuración de la representación del conocimiento.\n**Concepto Lógico**\n1. Completion\n2. Disjoint\n3. Subcategoría\n4. Predicado\n**Función en la Representación**\na) Indica que dos categorías no tienen miembros en común.\nb) La noción de que una categoría es un subconjunto de otra ($Basketballs \\subset Balls$).\nc) Expresa el límite superior de una enumeración (e.g., \"a lo sumo cuatro cursos\").\nd) Uno de los dos métodos en FOL para representar categorías, como $Basketball(b)$.\ne) Se utiliza para representar un evento o una acción en el Cálculo de Eventos.",
    "opciones": {
      "A": "1c, 2a, 3b, 4d",
      "B": "1a, 2c, 3d, 4e",
      "C": "1d, 2b, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Completion de una ecuación expresa la idea de \"a lo sumo\" (1c). **Disjoint** indica que dos categorías no tienen miembros en común (2a). **Subcategoría** se abrevia como $\\subset$ (3b). **Predicado** es una opción para representar categorías en FOL (4d)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione el problema de computación con la clase de completitud a la que pertenece en la jerarquía, si ha sido probado como $\\le_m$-completo.\n**Problema (Por sus siglas en inglés)**\n1. HP (Halting Problem)\n2. MP (Membership Problem)\n3. EMPTY (Emptiness Problem)\n4. TOTAL (Total Function Problem)\n**Clase de Complejidad**\na) $\\Sigma_3^0$\nb) $\\Pi_2^0$\nc) $\\Sigma_1^0$\nd) $\\Sigma_2^0$",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1d, 2c, 3b, 4a",
      "C": "1a, 2b, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "El HP es $\\le_m$-completo para $\\Sigma_1^0$ (1c). El MP es $\\le_m$-completo para $\\Sigma_2^0$ (2d). El EMPTY es $\\le_m$-completo para $\\Sigma_3^0$ (3a). El TOTAL es $\\le_m$-completo para $\\Pi_2^0$ (4b)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione los desafíos del uso de la lógica para el diagnóstico con el problema fundamental que surge al intentar construir reglas lógicas exhaustivas.\n**Desafío del Diagnóstico**\n1. Necesidad de reglas lógicamente exhaustivas.\n2. No todas las causas producen dolor.\n3. Fallo en el manejo de la observación parcial.\n**Problema Fundamental**\na) Requiere aumentar el lado izquierdo con calificaciones ilimitadas de posibles problemas.\nb) El agente no puede estar seguro de que el objeto que ha percibido sea un elemento típico.\nc) Se resuelve usando la Compleción de la igualdad para asegurar que la regla cubre todos los casos.\nd) Se puede resolver añadiendo una jerarquía de generalización limitada en lugar de disyunción abierta.\ne) Se resuelve reformulando la regla causal para ser más estricta.",
    "opciones": {
      "A": "1a, 2e, 3b",
      "B": "1c, 2a, 3d",
      "C": "1a, 2c, 3e"
    },
    "respuesta_correcta": "A",
    "justificacion": "Intentar hacer una regla lógicamente exhaustiva (1) requiere añadir una lista casi ilimitada de posibles problemas (1a). La regla causal $Cavity \\rightarrow Toothache$ es incorrecta porque no todas las cavidades causan dolor; la única forma de arreglarla es hacerla lógicamente exhaustiva (2e). El operar en entornos parcialmente observables genera incertidumbre (3), por lo que el agente no puede estar seguro de las propiedades del objeto percibido."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione el modelo de computación avanzado con el concepto de complejidad que mejor describe su naturaleza o uso.\n**Modelo de Computación**\n1. Máquina de Turing (TM)\n2. Máquina de Turing de una vía (One-way TM)\n3. Problema de Correspondencia de Post Modificado (MPCP)\n4. Nondeterministic Finite Automata (NFA)\n**Concepto de Complejidad / Función**\na) Reducción a la versión original para demostrar la indecidibilidad.\nb) La unidad de procesamiento que define la decidibilidad de un problema.\nc) Puede simular una TM ordinaria empujando un marcador hasta el final.\nd) La definición de sus estados usa una tripleta ordenada para modelar la posición de múltiples guijarros.\ne) Requiere tiempo polilogarítmico para ejecutarse en entornos paralelos.",
    "opciones": {
      "A": "1b, 2c, 3a, 4d",
      "B": "1c, 2b, 3d, 4a",
      "C": "1b, 2d, 3c, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "La TM (1) es el modelo utilizado para definir la decidibilidad (1b). La TM de una vía (2) puede simular TMs ordinarias moviendo marcadores a la derecha (2c). El MPCP (3) requiere que el match comience con el primer dominó, lo cual se elimina convirtiéndolo en PCP para demostrar la indecidibilidad (3a). Un NFA (4) utiliza un conjunto de estados $Q'$ definido como $Q^3$ (tripletas ordenadas) para modelar la posición de los guijarros blanco, verde y azul (4d)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Una empresa está desarrollando un sistema experto de diagnóstico y necesita un modelo lógico flexible para manejar la complejidad inherente. Relacione el enfoque de modelado de conocimiento con la característica que ofrece para manejar esta complejidad.\n**Enfoque Lógico**\n1. Uso de una Jerarquía de Generalización\n2. Separación de Propiedades Intrínsecas/Extrínsecas\n3. Uso de la categoría $Typical(Category)$\n**Característica de Flexibilidad**\na) Evita el problema de la **disyunción** permitiendo una búsqueda más acotada en el espacio de hipótesis.\nb) Permite que dos piezas de la misma sustancia retengan propiedades como la densidad y el color al ser cortadas.\nc) Permite que el agente aborde la incertidumbre que surge de la **observación parcial** en el entorno.\nd) Requiere que los objetos se traten como un _mass noun_ (sustancia) o un _count noun_ (objeto contable).\ne) Asegura que el costo de la inferencia sea polilogarítmico.",
    "opciones": {
      "A": "1d, 2b, 3c",
      "B": "1a, 2d, 3c",
      "C": "1a, 2b, 3e"
    },
    "respuesta_correcta": "B",
    "justificacion": "Una Jerarquía de Generalización (1) aborda el problema de la disyunción al usar literales más generales, como $LongWait(x)$, limitando el espacio de hipótesis (1a). La distinción entre propiedades Intrínsecas y Extrínsecas (2) define si una categoría es una **sustancia** (masa, propiedades intrínsecas) o un **objeto** (recuento, propiedades extrínsecas) (2d). El uso de $Typical(Category)$ (3) separa lo que es verdadero de todos los casos de lo que es verdadero solo de los casos típicos, abordando la incertidumbre de la observación parcial (3c)."
  },
  {
    "tema": "Algoritmia - Lógica computacional",
    "pregunta": "Relacione los tres tipos de problemas en la clasificación de complejidad con el principio que mejor describe por qué la categoría se define como tal.\n**Clasificación de Problemas**\n1. Problemas que han sido probados como intratables.\n2. Problemas que tienen algoritmos de tiempo polinómico ($P$).\n3. Problemas sin algoritmo polinómico conocido ($NP$ sin prueba de $P \\ne NP$).\n**Principio de Clasificación**\na) Se definen mediante algoritmos cuyo tiempo de ejecución está acotado por una función polinómica de su tamaño.\nb) Han sido probados como imposibles de resolver con cualquier algoritmo de tiempo polinómico.\nc) Son aquellos para los cuales no se ha probado que un algoritmo de tiempo polinómico sea imposible.\nd) Requieren que el número de unidades de procesamiento sea polinómico en el tamaño del problema.",
    "opciones": {
      "A": "1c, 2d, 3b",
      "B": "1b, 2a, 3c",
      "C": "1a, 2c, 3d"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los problemas probados como intratables (1) son aquellos para los cuales se ha demostrado que es imposible un algoritmo de tiempo polinómico (1b). Los problemas $P$ (2) son aquellos resueltos por algoritmos con tiempo acotado por una función polinómica (2a). Los problemas sin algoritmo polinómico conocido (3) son aquellos para los cuales no se ha probado que tal algoritmo sea imposible (3c)."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "¿Cuál es la representación correcta del número decimal 76 en su Complemento a 2 (C2), asumiendo una representación de 8 bits (1 byte)?",
    "opciones": {
      "A": "01001100",
      "B": "10110100",
      "C": "11011010"
    },
    "respuesta_correcta": "B",
    "justificacion": "Para obtener el C2 de -76:\n1. Magnitud verdadera (76 en binario de 8 bits): 01001100.\n2. Complemento a 1 (inversión de bits): 10110011.\n3. Complemento a 2 (sumar 1 a C1): $10110011 + 1 = 10110100$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "¿Cuál es la propiedad que debe cumplir una relación binaria $R$ para ser clasificada como una relación de equivalencia, además de ser reflexiva y simétrica?",
    "opciones": {
      "A": "Antisímétrica",
      "B": "Irreflexiva",
      "C": "Transitiva"
    },
    "respuesta_correcta": "C",
    "justificacion": "Una relación es de equivalencia si y solo si es reflexiva, simétrica y transitiva. La propiedad de transitividad establece que si $a R b$ y $b R c$, entonces $a R c$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Si $p$ es la proposición \"Juan estudia la licenciatura en matemáticas\" y $c$ es \"Juan estudia la licenciatura en ciencias computacionales\", ¿cuál es la notación lógica para el enunciado \"Juan estudia la licenciatura en matemáticas pero no estudia la licenciatura en ciencias computacionales\"?",
    "opciones": {
      "A": "$p \\lor \\neg c$",
      "B": "$p \\land \\neg c$",
      "C": "$\\neg (p \\land c)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El término \"pero\" se traduce lógicamente como una conjunción ($\\land$), y la negación se usa para \"no estudia\" ($\\neg c$). Por lo tanto, es $p \\land \\neg c$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "¿Cuál es el principal propósito del uso del método de reducción de Mapas de Karnaugh en el Álgebra de Boole?",
    "opciones": {
      "A": "Convertir expresiones booleanas a su forma canónica normal.",
      "B": "Determinar la validez de un argumento lógico complejo.",
      "C": "Simplificar una función booleana para reducir el número de compuertas necesarias."
    },
    "respuesta_correcta": "C",
    "justificacion": "El Mapa de Karnaugh es una herramienta para obtener la expresión booleana simplificada en sumas de productos o productos de sumas. Esto se traduce directamente en la optimización del circuito lógico, reduciendo la cantidad de compuertas."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Considere el argumento formal: _Si se realiza un buen diseño de la base de datos ($p$) y se hace una buena programación ($q$), entonces se accederá rápidamente a la información ($r$)\\_. _Si no se hace buena programación ($\\neg q$), entonces toma mucho tiempo corregir el programa ($s$)\\_. _Por lo tanto, si no se accede rápidamente a la información ($\\neg r$) y toma mucho tiempo corregir el programa ($s$), entonces no se ha realizado un buen diseño de la base de datos ($\\neg p$)\\_. ¿Cuál es la representación formal de este argumento?",
    "opciones": {
      "A": "$[(p \\land q) \\rightarrow r] \\land [\\neg q \\rightarrow s] \\implies [(\\neg r \\land s) \\rightarrow \\neg p]$",
      "B": "$[p \\rightarrow (q \\land r)] \\land [\\neg q \\rightarrow s] \\implies [(\\neg r \\lor s) \\rightarrow \\neg p]$",
      "C": "$[(p \\lor q) \\rightarrow r] \\land [q \\rightarrow s] \\implies [\\neg r \\rightarrow \\neg p]$"
    },
    "respuesta_correcta": "A",
    "justificacion": "La primera premisa es la conjunción de $p$ y $q$ implicando $r$. La segunda premisa es $\\neg q$ implicando $s$. La conclusión se forma por la conjunción de $\\neg r$ y $s$ implicando $\\neg p$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Considere la proposición en lógica de primer orden: \"Existe una persona $x$ en mi clase tal que para toda persona $y$ en mi clase, $x$ es al menos de la misma edad que $y$.\" ¿Cuál es la negación formal (usando las leyes de De Morgan generalizadas) de esta proposición?",
    "opciones": {
      "A": "$\\forall x \\exists y \\neg P(x, y)$ (donde $P(x, y)$ es \"x es al menos de la misma edad que y\").",
      "B": "$\\forall x \\exists y (P(x) \\land \\neg P(y))$",
      "C": "$\\exists x \\forall y P(x, y)$"
    },
    "respuesta_correcta": "A",
    "justificacion": "Si la proposición original es $\\exists x \\forall y P(x, y)$, la negación de una proposición cuantificada se obtiene negando los cuantificadores (cambiando $\\exists$ por $\\forall$ y $\\forall$ por $\\exists$) y negando la función proposicional. Por lo tanto, $\\neg (\\exists x \\forall y P(x, y))$ se convierte en $\\forall x \\exists y \\neg P(x, y)$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Si se tiene un número en base 13 como $7C9.A_{(13)}$ y otro número en base 17 como $1A3.0283_{(17)}$, ¿qué operación requiere el mayor cuidado en el manejo de símbolos y valores posicionales entre las bases dadas?",
    "opciones": {
      "A": "Suma de dos cantidades en complemento a 2 en base binaria.",
      "B": "Conversión de $7C9.A_{(13)}$ a base 10.",
      "C": "Suma de $7C9.A_{(13)}$ y $1A3.0283_{(17)}$ directamente en base decimal."
    },
    "respuesta_correcta": "B",
    "justificacion": "Las bases 13 y 17 son bases arbitrarias que usan símbolos para dígitos mayores a 9 (como C y A). Si bien la suma en C2 es compleja, la conversión entre una base arbitraria como la base 13 (donde $C$ vale 12, $A$ vale 10) y la base decimal requiere manejar correctamente los símbolos alfabéticos y sus valores posicionales específicos, lo que requiere un conocimiento riguroso de la generalización de las conversiones."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Una función booleana $F$ ha sido simplificada, y para su implementación solo se dispone de compuertas NOR. ¿Cuál principio justifica la posibilidad de implementar cualquier función $F$ utilizando exclusivamente compuertas NOR?",
    "opciones": {
      "A": "El principio de dualidad, que asegura la existencia del complemento de la función.",
      "B": "El teorema de Shannon, que permite expandir la función en productos de sumas.",
      "C": "El carácter universal de la compuerta NOR, que permite simular las compuertas AND, OR y NOT."
    },
    "respuesta_correcta": "C",
    "justificacion": "Las compuertas NOR (así como las NAND) son compuertas universales. Esto significa que, con cualquiera de ellas, se pueden construir las compuertas lógicas básicas (AND, OR, NOT), y por lo tanto, cualquier circuito lógico."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Las variables locales en un procedimiento o función se pasan por **_______**, lo que significa que son tratadas como variables locales dentro del procedimiento. En cambio, los parámetros de tipo matriz se pasan por **_______**, lo cual significa que toda modificación efectuada dentro del procedimiento se ve reflejada en la matriz original.",
    "opciones": {
      "A": "valor; referencia",
      "B": "referencia; valor",
      "C": "constante; variable"
    },
    "respuesta_correcta": "A",
    "justificacion": "Los parámetros escalares (variables locales) se pasan por valor. Los parámetros tipo matriz o estructura se pasan por referencia, reflejando cualquier modificación realizada."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "El proceso de obtención de la representación de un número negativo en Complemento a 2 requiere primero obtener su Magnitud Verdadera, luego su **_______**, y finalmente sumarle 1 para obtener el Complemento a 2.",
    "opciones": {
      "A": "Residuo",
      "B": "Complemento a 1",
      "C": "Exceso a $2^{n-1}$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El cálculo de Complemento a 2 sigue los pasos: Magnitud Verdadera $\\rightarrow$ Complemento a 1 (inversión de bits) $\\rightarrow$ Complemento a 2 (sumar 1 a C1)."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "En la Teoría de Conjuntos, si $H$, $C$ y $D$ son tres conjuntos, la región del diagrama de Venn que representa a los elementos que están en el conjunto $H$ y en el conjunto $C$, pero no en el conjunto $D$, se representa mediante la operación lógica $H \\cap C \\cap \\neg D$.",
    "opciones": {
      "A": "$\\neg (H \\cup C) \\cup D$",
      "B": "$H \\cap C \\cap \\neg D$",
      "C": "$(H \\cup C) \\setminus D$"
    },
    "respuesta_correcta": "B",
    "justificacion": "La conjunción $H \\cap C$ representa \"estar en $H$ y en $C$\". El requisito de \"pero no en $D$\" se logra intersectando con la negación de $D$ ($\\neg D$)."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Para que un argumento sea considerado válido, el valor de verdad de su conclusión debe ser **_______** en todos los casos en los que el valor de verdad de sus premisas es **_______**.",
    "opciones": {
      "A": "Falso; Verdadero",
      "B": "Verdadero; Falso",
      "C": "Verdadero; Verdadero"
    },
    "respuesta_correcta": "C",
    "justificacion": "Un argumento es válido si es imposible que las premisas sean verdaderas y la conclusión sea falsa. Por lo tanto, si las premisas son Verdaderas, la conclusión _debe_ ser Verdadera para que el argumento se mantenga."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "El cálculo del total anual de producción para un arreglo tridimensional $A[I, J, L]$ requiere la acumulación de cantidades mensuales (índice $J$). Si se tienen los límites inferiores $I_{inf}=1$, $J_{inf}=1$ y $L_{inf}=1$, y los límites superiores $I_{sup}=5$, $J_{sup}=12$ y $L_{sup}=3$, el pseudocódigo para calcular $\\sum_{I=1}^{5} \\sum_{J=1}^{12} \\sum_{L=1}^{3} A[I, J, L]$ es:\n```\nHacer SUMA <- 0\nRepetir con I desde 1 hasta 5\n    Repetir con J desde 1 hasta 12\n        Repetir con L desde 1 hasta 3\n            Hacer SUMA <- SUMA + A[I, J, L]\n        _________________________\n    _________________________\n_________________________\nEscribir SUMA\n```\nEl/Los elemento(s) que completa(n) correctamente el pseudocódigo es/son...",
    "opciones": {
      "A": "Fin del ciclo del paso L, Fin del ciclo del paso J, Fin del ciclo del paso I",
      "B": "Escribir A[I, J, L], Fin del ciclo del paso J, Fin del ciclo del paso I",
      "C": "Hacer SUMA <- SUMA + 1, Fin del ciclo del paso J, Fin del ciclo del paso I"
    },
    "respuesta_correcta": "A",
    "justificacion": "La operación de acumulación (Hacer SUMA $\\leftarrow$ SUMA + A[I, J, L]) se realiza dentro del ciclo más interno. Para que el pseudocódigo sea funcional, los ciclos deben cerrarse con las instrucciones de fin de ciclo correspondientes."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Considere la suma en Complemento a 2 de dos números representados en 2 bytes (16 bits). Si se suman $-225_{(10)}$ y $76_{(10)}$, la representación binaria resultante de $2$ bytes del número $-149_{(10)}$ es $11111111101101001_{(2)}$. Para evitar el desbordamiento, se requiere agregar un byte adicional de extensión de signo. La representación final de 3 bytes (24 bits) para el número $-149_{(10)}$ es:",
    "opciones": {
      "A": "$00000000\\ 11111111\\ 10110100$",
      "B": "$11111111\\ 11111111\\ 01001011$",
      "C": "$11111111\\ 11111111\\ 10110100$"
    },
    "respuesta_correcta": "C",
    "justificacion": "Cuando se extiende la representación de un número negativo en C2, se debe realizar la extensión del signo. El bit más significativo de $-149_{(10)}$ en 2 bytes es 1. Para extender a 3 bytes (24 bits), se agregan 8 bits con el valor 1 (el bit de signo) al inicio. La representación de 2 bytes es $11111111\\ 10110100_{(2)}$. La extensión a 3 bytes es $11111111\\ 11111111\\ 10110100_{(2)}$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "La definición de una región de ciclo $R$ en el análisis de flujo de datos requiere un cálculo iterativo. El proceso implica realizar el cálculo de la figura $9.50(b)$ y una pasada de arriba hacia abajo para buscar los valores del flujo de datos al inicio de cada región. Si $R_n$ es la última región, su cálculo de entrada es $ENT[R_n] = ENT[ENTRADA]$. El cálculo para cualquier otra región $R$ en $\\{R_1, \\ldots, R_{n-1}\\}$, en orden descendente, es:",
    "opciones": {
      "A": "$ENT[R] = f_{R'} , ENT[R] (ENT[R'])$",
      "B": "$ENT[R] = f_{R, ENT[B]} = I$",
      "C": "$ENT[R] = \\text{max}(ENT[R_1], ENT[R_2], \\dots)$"
    },
    "respuesta_correcta": "A",
    "justificacion": "Para una región $R$ en el orden descendente, se calcula $ENT[R]$ mediante la función $f_{R'}$ aplicada a la entrada de la región $R'$ inmediata anterior, lo que se denota como $ENT[R] = f_{R'} , ENT[R] (ENT[R'])$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Utilizando la simplificación booleana por Mapas de Karnaugh, si la función de salida simplificada en sumas de productos es $F = A'B'C'E + AB'C'E + BC + ABC'D' + AB'CE + A'B'C'DE' + ABC'DE$ ¿Cuál de las siguientes es una expresión lógicamente equivalente a la anterior?",
    "opciones": {
      "A": "$F = B'C'E + A'B'C'D + ABD' + ABC'E + BC$",
      "B": "$F = A'B'C'D'E + A'B'C'DE'$",
      "C": "$F = (A + C)(B + C')(C + D')$"
    },
    "respuesta_correcta": "A",
    "justificacion": "La expresión original corresponde a un ejemplo de simplificación extensa. Durante el proceso de simplificación, se pueden utilizar tautologías y equivalencias lógicas (como $B'C'E(A' + A)$ o $BC(A' + A)$) para reducir la expresión. La expresión simplificada $F = B'C'E + A'B'C'D + ABD' + ABC'E + BC$ es una forma intermedia o final resultante de la aplicación rigurosa de estas leyes."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione el concepto de Lógica Matemática con su definición:\n**[Conjunto A]**\n1. Proposición Bicondicional\n2. Proposición Condicional\n3. Lógica de Primer Orden\n4. Cuantificadores\n**[Conjunto B]**\na) Permite expresar que una proposición es válida para _todos_ o _existe al menos uno_.\nb) Expresión lógica de la forma \"Si $p$, entonces $q$\" ($p \\rightarrow q$).\nc) Extensión de la lógica proposicional que incluye cuantificadores y predicados.\nd) Expresión lógica de la forma \"$p$ si y solo si $q$\" ($p \\leftrightarrow q$).\ne) Argumento con premisas verdaderas y conclusión falsa.",
    "opciones": {
      "A": "1-b, 2-d, 3-a, 4-c",
      "B": "1-d, 2-b, 3-c, 4-a",
      "C": "1-d, 2-e, 3-c, 4-b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-d: La Proposición Bicondicional se denota como $p \\leftrightarrow q$, que significa \"$p$ si y solo si $q$\".\n2-b: La Proposición Condicional se denota como $p \\rightarrow q$, que significa \"Si $p$, entonces $q$\".\n3-c: La Lógica de Primer Orden, a diferencia de la proposicional, incorpora predicados y cuantificadores.\n4-a: Los Cuantificadores (universal $\\forall$ y existencial $\\exists$) se usan para especificar si la proposición aplica a todos o a algunos elementos."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione el tipo de operación de conjuntos o lógica con su descripción funcional:\n**[Conjunto A]**\n1. Conjunción ($\\land$)\n2. Disyunción ($\\lor$)\n3. Negación ($\\neg$)\n4. Intersección de conjuntos ($\\cap$)\n**[Conjunto B]**\na) Es verdadera si al menos una de las proposiciones es verdadera.\nb) Invierte el valor de verdad de una proposición.\nc) Es verdadera si ambas proposiciones son verdaderas.\nd) Conjunto de elementos que pertenecen a ambos conjuntos.\ne) Conjunto de elementos que pertenecen a cualquiera de los conjuntos.",
    "opciones": {
      "A": "1-c, 2-a, 3-b, 4-d",
      "B": "1-a, 2-c, 3-b, 4-e",
      "C": "1-c, 2-e, 3-b, 4-a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: La conjunción ($p \\land q$) es verdadera solo si $p$ y $q$ son verdaderas.\n2-a: La disyunción ($p \\lor q$) es verdadera si $p$ o $q$ es verdadera.\n3-b: La negación ($\\neg p$) invierte el valor de verdad de $p$.\n4-d: La Intersección de conjuntos produce los elementos comunes a ambos."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione las estructuras de MD con su campo de aplicación principal:\n**[Conjunto A]**\n1. Matrices\n2. Bases Numéricas\n3. Teoría de Relaciones\n4. Álgebra de Boole\n**[Conjunto B]**\na) Representación de datos estructurados en una tabla.\nb) Fundamento del diseño de la lógica digital y circuitos de conmutación.\nc) Análisis de algoritmos y solución de problemas en diversos ámbitos.\nd) Representación de cantidades para operaciones aritméticas de la computadora.\ne) Implementación de estructuras de datos complejos (e.g., matrices de adyacencia en grafos).",
    "opciones": {
      "A": "1-a, 2-d, 3-e, 4-b",
      "B": "1-e, 2-c, 3-a, 4-d",
      "C": "1-c, 2-d, 3-a, 4-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Las matrices son estructuras de datos que almacenan elementos en renglones y columnas.\n2-d: Los sistemas numéricos (binario, octal, hexadecimal) se usan para representar las cantidades con las que opera la máquina.\n3-e: La teoría de relaciones se usa en bases de datos relacionales y en la representación de conexiones, como las matrices de adyacencia de los grafos.\n4-b: El Álgebra de Boole se aplica directamente al diseño de circuitos lógicos, optimizando la lógica digital."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione los errores lógicos con su descripción:\n**[Conjunto A]**\n1. Error Converso\n2. Error Contrario\n3. Argumento Válido (Modus Ponens)\n4. Argumento Válido (Modus Tollens)\n**[Conjunto B]**\na) Si $p \\rightarrow q$ es premisa, y $\\neg q$ es premisa, la conclusión es $\\neg p$.\nb) Si $p \\rightarrow q$ es premisa, y $\\neg p$ es premisa, la conclusión incorrecta es $\\neg q$.\nc) Si $p \\rightarrow q$ es premisa, y $q$ es premisa, la conclusión incorrecta es $p$.\nd) Si $p \\rightarrow q$ es premisa, y $p$ es premisa, la conclusión es $q$.\ne) La conclusión es siempre verdadera, sin importar las premisas.",
    "opciones": {
      "A": "1-c, 2-b, 3-d, 4-a",
      "B": "1-b, 2-c, 3-a, 4-d",
      "C": "1-c, 2-d, 3-a, 4-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: El error converso se produce al concluir $p$ a partir de $p \\rightarrow q$ y $q$.\n2-b: El error contrario se produce al concluir $\\neg q$ a partir de $p \\rightarrow q$ y $\\neg p$.\n3-d: Modus Ponens es la regla válida: $p \\rightarrow q$ y $p$ implican $q$.\n4-a: Modus Tollens es la regla válida: $p \\rightarrow q$ y $\\neg q$ implican $\\neg p$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione los conceptos de programación con su definición o aplicación en Algoritmia y MD:\n**[Conjunto A]**\n1. Matriz\n2. Puntero\n3. Multiplicación a la Russe\n4. Recursividad\n**[Conjunto B]**\na) Técnica que se utiliza cuando un procedimiento o función se llama a sí mismo.\nb) Una estructura de datos que consta de un número fijo de ítems del mismo tipo, almacenados contiguos.\nc) Mecanismo que se usa para crear dinámicamente registros o acceder a ellos.\nd) Algoritmo de multiplicación de enteros grandes cuyo tiempo requerido es por el orden de $mn$ (donde $m$ y $n$ son tamaños de operandos).\ne) Secuencia ordenada de elementos que permite inserción y eliminación rápidas.",
    "opciones": {
      "A": "1-b, 2-c, 3-d, 4-a",
      "B": "1-c, 2-a, 3-d, 4-b",
      "C": "1-b, 2-d, 3-a, 4-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Una matriz es una estructura de datos con número fijo de ítems del mismo tipo, almacenados contiguamente.\n2-c: Los punteros se utilizan para la creación dinámica de registros o para hacer alusión a campos.\n3-d: La multiplicación a la Russe requiere un tiempo por el orden de $mn$ para multiplicar enteros grandes de tamaños $m$ y $n$.\n4-a: La recursividad implica que una función o procedimiento se llama a sí mismo."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Un ingeniero debe convertir una función booleana a su forma más compacta para luego implementarla usando solo compuertas NAND. Relacione las tareas con el concepto de MD que se aplica en cada paso:\n**[Conjunto A]**\n1. Simplificación a Suma de Productos (SOP)\n2. Representación Gráfica de Minterms\n3. Implementación exclusiva con NAND\n4. Prueba de Equivalencia\n**[Conjunto B]**\na) Teoremas y leyes del Álgebra de Boole (e.g., asociatividad, absorción).\nb) Uso de tablas de verdad completas para demostrar igualdad entre la función original y la simplificada.\nc) Uso de Mapas de Karnaugh para agrupación y minimización.\nd) Principio de compuertas universales.\ne) Lógica de primer orden.",
    "opciones": {
      "A": "1-c, 2-a, 3-d, 4-b",
      "B": "1-c, 2-b, 3-d, 4-a",
      "C": "1-c, 2-d, 3-a, 4-b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: La simplificación a SOP se realiza mediante técnicas como los Mapas de Karnaugh.\n2-a: Aunque los mapas de Karnaugh son visuales, su justificación y la realización de la simplificación implican la aplicación de los teoremas y leyes del álgebra de Boole.\n3-d: La implementación con un solo tipo de compuerta (NAND o NOR) se basa en el principio de compuertas universales.\n4-b: La verificación de que la expresión simplificada es idéntica a la original se comprueba mediante la tabla de verdad, donde las columnas deben coincidir en todas sus líneas."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Relacione el concepto avanzado de la teoría de relaciones con el requisito de propiedad correspondiente que debe cumplir:\n**[Conjunto A]**\n1. Cerradura Transitiva\n2. Relación Simétrica\n3. Clases de Equivalencia\n4. Transitividad\n**[Conjunto B]**\na) Si la relación tiene $a R b$, también debe tener $b R a$.\nb) Partición de un conjunto en subconjuntos donde todos los elementos de un subconjunto están relacionados entre sí.\nc) La propiedad que debe agregarse a una relación para que satisfaga la condición de ser transitiva.\nd) Si $a R b$ y $b R c$, entonces $a R c$.\ne) Si la relación tiene $a R a$ para todo $a$ en el dominio.",
    "opciones": {
      "A": "1-c, 2-a, 3-b, 4-d",
      "B": "1-a, 2-c, 3-d, 4-b",
      "C": "1-d, 2-a, 3-b, 4-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: La cerradura transitiva es el mecanismo para hacer que una relación que no es transitiva cumpla con esta propiedad.\n2-a: Simetría: si $a$ está relacionado con $b$, $b$ debe estar relacionado con $a$.\n3-b: Las clases de equivalencia son los subconjuntos resultantes de una relación de equivalencia, y forman una partición del conjunto original.\n4-d: Transitividad: Si existe una conexión de $a$ a $c$ a través de $b$."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Considere las siguientes expresiones aritméticas que involucran bases numéricas arbitrarias y operaciones de bajo nivel. Relacione la operación con el concepto de MD que se aplica:\n**[Conjunto A]**\n1. Suma $2A.76_{(12)} + 5B7468A.9_{(12)}$\n2. Cálculo de la fecha del Domingo de Pascua\n3. Suma en Complemento a 2\n4. Conversión de $D7C3F.5G_{(18)}$ a base 10\n**[Conjunto B]**\na) Aplicación de un algoritmo basado en residuos (módulo) y divisiones sucesivas.\nb) Conversión y manejo posicional de caracteres alfabéticos como dígitos.\nc) Realización de la operación aritmética en sistemas no decimales.\nd) Uso de bits de signo y operaciones a nivel binario para simular la resta.\ne) Problema de combinatoria basado en reglas de conteo.",
    "opciones": {
      "A": "1-c, 2-a, 3-d, 4-b",
      "B": "1-d, 2-a, 3-c, 4-b",
      "C": "1-c, 2-e, 3-d, 4-a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: La suma en base 12 es una operación aritmética en un sistema no decimal, que requiere un manejo cuidadoso de los acarreos.\n2-a: El cálculo de la fecha de Pascua se realiza mediante un algoritmo que utiliza operaciones módulo y manipulación de variables temporales, como $a = año \\pmod{19}$.\n3-d: El Complemento a 2 se utiliza para realizar la resta mediante la suma binaria, apoyándose en la representación de signo.\n4-b: La base 18 requiere la conversión de símbolos alfabéticos $D, F, G$ a sus valores numéricos correspondientes, lo cual es fundamental en la generalización de conversiones."
  },
  {
    "tema": "Algoritmia - Matemáticas discretas",
    "pregunta": "Un equipo de desarrollo necesita diseñar una Unidad Aritmético Lógica (ALU) eficiente, para lo cual debe integrar conceptos de bases numéricas, álgebra de Boole y simplificación. Relacione las tareas de diseño con el concepto de MD subyacente que las resuelve:\n**[Conjunto A]**\n1. Definición del método para realizar la resta\n2. Obtención de la expresión lógica minimal\n3. Implementación del circuito final con bajo costo\n4. Verificación de la correctitud de la implementación\n**[Conjunto B]**\na) El uso exclusivo de compuertas NOR o NAND, aprovechando su universalidad.\nb) El análisis de la tabla de verdad de la función simplificada.\nc) Uso de Mapas de Karnaugh de 5 variables.\nd) Aplicación de la Suma en Complemento a 2.\ne) El uso de redes de Petri.",
    "opciones": {
      "A": "1-d, 2-c, 3-a, 4-b",
      "B": "1-a, 2-c, 3-d, 4-b",
      "C": "1-d, 2-a, 3-b, 4-c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-d: El método más eficiente para realizar la resta en una ALU es mediante la aplicación de la Suma en Complemento a 2 (C2), lo que requiere solo un circuito sumador.\n2-c: La obtención de la expresión lógica minimal de la función del circuito (por ejemplo, para el sumador completo) se logra mediante herramientas de minimización, como los Mapas de Karnaugh.\n3-a: La implementación más económica y modular se logra utilizando compuertas universales (NAND o NOR).\n4-b: Una vez diseñado el circuito y obtenida la función booleana simplificada, la prueba rigurosa de que la función es lógicamente equivalente a la original se hace mediante la Tabla de Verdad."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "¿Qué representa la notación asintótica $O(f(n))$ en el contexto del análisis de algoritmos?",
    "opciones": {
      "A": "Una cota inferior para el tiempo de ejecución",
      "B": "El tiempo de ejecución exacto",
      "C": "Una cota superior para el tiempo de ejecución"
    },
    "respuesta_correcta": "C",
    "justificacion": "La notación $O$ (Big O) se utiliza para indicar una cota superior para el tiempo $t(n)$ requerido por un algoritmo, implicando que $t(n)$ no crece más rápido que $f(n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "¿Cuál es el principal objetivo del análisis del caso peor (worst case) de un algoritmo?",
    "opciones": {
      "A": "Encontrar el tiempo promedio requerido por el algoritmo para todas las entradas posibles.",
      "B": "Determinar el límite superior del tiempo de ejecución que el algoritmo puede requerir.",
      "C": "Calcular el tiempo de ejecución para entradas que se encuentran en orden aleatorio."
    },
    "respuesta_correcta": "B",
    "justificacion": "El caso peor considera los ejemplares (entradas) que obligan al algoritmo a ejecutarse durante la máxima cantidad de tiempo, proporcionando el límite superior del tiempo de respuesta."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En el contexto de un lenguaje de programación, ¿cuál es la característica fundamental de una función recursiva?",
    "opciones": {
      "A": "Que opera solo con tipos de datos estructurados como registros.",
      "B": "Que se llama a sí misma y debe tener una condición de finalización previamente definida.",
      "C": "Que siempre requiere un tiempo de ejecución de orden lineal $O(n)$."
    },
    "respuesta_correcta": "B",
    "justificacion": "La recursividad es cuando una función se llama a sí misma. Para que finalice la recursividad, debe existir una condición previamente definida."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Si un algoritmo está representado por tres bucles anidados donde cada bucle itera $n$ veces, ¿cuál es el orden asintótico del tiempo requerido, asumiendo que el cuerpo del bucle interno es una operación elemental?",
    "opciones": {
      "A": "$\\Theta(n^2)$",
      "B": "$\\Theta(n)$",
      "C": "$\\Theta(n^3)$"
    },
    "respuesta_correcta": "C",
    "justificacion": "Tres bucles anidados que iteran $n$ veces cada uno resultan en una complejidad de $n \\times n \\times n = n^3$. Esto se expresa como $\\Theta(n^3)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En el análisis asintótico, ¿por qué un algoritmo con complejidad $\\Theta(n\\log n)$ se considera más rápido que uno con complejidad $\\Theta(n^2)$ para ejemplares grandes?",
    "opciones": {
      "A": "Porque la complejidad $\\Theta(n \\log n)$ solo considera constantes multiplicativas más pequeñas.",
      "B": "Porque $\\Theta(n \\log n)$ requiere tiempo cuadrático, mientras que $\\Theta(n^2)$ es lineal.",
      "C": "Porque la ganancia de eficiencia del logaritmo es superior al aumento cuadrático a medida que $n$ crece."
    },
    "respuesta_correcta": "C",
    "justificacion": "Para operadores de gran longitud, los algoritmos $\\Theta(n\\log n)$ son asintóticamente más eficientes y la ganancia de eficiencia de la complejidad logarítmica es superior al crecimiento cuadrático cuando $n$ aumenta."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "¿Cuál es el objetivo principal de utilizar la función potencial ($\\Phi$) en el análisis amortizado de algoritmos?",
    "opciones": {
      "A": "Calcular el tiempo de ejecución del caso peor de una operación específica.",
      "B": "Determinar la complejidad asintótica de la secuencia de operaciones en el caso medio.",
      "C": "Evaluar el costo promedio por operación de una secuencia, incorporando el costo real y la desorganización de la estructura de datos."
    },
    "respuesta_correcta": "C",
    "justificacion": "La función potencial se utiliza para el análisis amortizado, donde el tiempo amortizado es el costo real más el cambio en el estado de organización ($\\Phi_i - \\Phi_{i-1}$), permitiendo evaluar el costo promedio de las operaciones."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Si el tiempo de ejecución $T(n)$ de un algoritmo se encuentra en $\\Theta(f(n))$, ¿qué implicación tiene esta notación respecto a las cotas superiores e inferiores del algoritmo?",
    "opciones": {
      "A": "$T(n)$ solo tiene una cota superior $O(f(n))$ y la cota inferior no está definida.",
      "B": "$T(n)$ tiene una cota inferior $\\Omega(f(n))$ y una cota superior $O(f(n))$.",
      "C": "$T(n)$ tiene una cota inferior $\\Omega(f(n))$, pero $O(f(n))$ no se aplica."
    },
    "respuesta_correcta": "B",
    "justificacion": "$T(n) \\in \\Theta(f(n))$ es equivalente a que $T(n) \\in O(f(n)) \\cap \\Omega(f(n))$, lo que significa que el tiempo está acotado tanto superior como inferiormente por la función $f(n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "El algoritmo de multiplicación \"a la russe\" para enteros de tamaño $m$ y $n$ requiere un tiempo del orden de $mn$. Si se utiliza esta técnica para multiplicar dos enteros muy grandes de $n$ dígitos cada uno, ¿cuál sería el orden de complejidad?",
    "opciones": {
      "A": "$\\Theta(n)$",
      "B": "$\\Theta(n^2)$",
      "C": "$\\Theta(n^3)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "Si se multiplican dos enteros grandes de $n$ dígitos, y se multiplica cada palabra de uno de los operandos por cada palabra del otro, el tiempo requerido es del orden de $mn$ donde $m \\approx n$, resultando en una complejidad de $\\Theta(n^2)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Una operación cuyo tiempo de ejecución se puede acotar superiormente por una constante, independientemente del tamaño de la entrada, se denomina **_ _ _ _ _ _ _ _ _ _ _**.",
    "opciones": {
      "A": "Operación recursiva",
      "B": "Operación elemental",
      "C": "Operación de alto nivel"
    },
    "respuesta_correcta": "B",
    "justificacion": "Una operación elemental es aquella cuyo tiempo de ejecución está acotado superiormente por una constante que solo depende de la máquina en particular, no del tamaño de $n$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Para solucionar la recursividad de una función, como la de Fibonacci $f_n =f_{n-1} + f_{n-2}$, debe existir una **_ _ _ _ _ _ _ _ _ _ _** que detenga el proceso.",
    "opciones": {
      "A": "función de orden superior",
      "B": "condición de finalización",
      "C": "ecuación de optimización"
    },
    "respuesta_correcta": "B",
    "justificacion": "La recursividad ocurre cuando una función se llama a sí misma, y para finalizar, debe existir una condición previamente definida o condición de finalización."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "La **_ _ _ _ _ _ _ _ _ _ _** permite realizar simplificaciones sustanciales, como expresar el tiempo requerido por un algoritmo salvo por una constante multiplicativa.",
    "opciones": {
      "A": "Notación binaria",
      "B": "Notación asintótica",
      "C": "Notación de recursión"
    },
    "respuesta_correcta": "B",
    "justificacion": "La notación asintótica permite realizar simplificaciones sustanciales, al interesarse en medir algo más tangible que el tiempo de ejecución, como el orden de crecimiento."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Se dice que $t(n)$ tiende al límite $a$ cuando $n$ tiende a infinito, si para todo número real positivo $\\delta$, existe un umbral $n_0(\\delta)$ tal que la diferencia entre $t(n)$ y $a$ es menor que $\\delta$ para todos los valores de $n$ **_ _ _ _ _ _ _ _ _ _ _**.",
    "opciones": {
      "A": "pequeños o cercanos a cero",
      "B": "mayores que $n_0(\\delta)$",
      "C": "que están en el rango de 1 a 100"
    },
    "respuesta_correcta": "B",
    "justificacion": "La definición de límite indica que para todo $\\delta > 0$ existe un $n_0(\\delta)$ tal que $|f(n) - a| < \\delta$ para los valores de $n$ mayores que $n_0(\\delta)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Un algoritmo de \"divide y vencerás\" tiene una relación de recurrencia $T(n) = T(\\lfloor n/2 \\rfloor) + 2T(\\lceil n/2 \\rceil) + cn$. Si se aplica un cambio de variable donde $n$ es potencia exacta de $b$, la solución es de orden **_ _ _ _ _ _ _ _ _ _ _**.",
    "opciones": {
      "A": "$\\Theta(n^2)$",
      "B": "$\\Theta(n \\log^2 n)$",
      "C": "$\\Theta(n)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "La relación $T(n) = T(\\lfloor n/2 \\rfloor) + 2T(\\lceil n/2\\rceil) + cn$ (una versión de $T(n)=T(n/b)+T(n/2)+cn$) tiene un término dominante que resulta en $\\Theta(n \\log^2 n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "El análisis de algoritmos de ordenación (como Quicksort o Mergesort) típicamente demuestra que, si todas las permutaciones iniciales son igualmente probables, el tiempo requerido en el caso medio es de orden **_ _ _ _ _ _ _ _ _ _ _**.",
    "opciones": {
      "A": "$\\Theta(n^2)$",
      "B": "$\\Theta(n \\log n)$",
      "C": "$\\Theta(n^3)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El tiempo medio requerido para la ordenación por mezcla (Merge Sort) y el ordenamiento rápido (Quick Sort) es típicamente $\\Theta(n\\log n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En el análisis amortizado, el tiempo amortizado de la $i$-ésima operación ($\\hat{t}_i$) se define como el costo real $t_i$ más **_ _ _ _ _ _ _ _ _ _ _** de la función potencial.",
    "opciones": {
      "A": "la resta del valor inicial $\\Phi_0$",
      "B": "la suma del valor actual $\\Phi_i$",
      "C": "la diferencia $\\Phi_i - \\Phi_{i-1}$"
    },
    "respuesta_correcta": "C",
    "justificacion": "Formalmente, el tiempo amortizado requerido para la $i$-ésima operación es $t_i + \\Phi_i - \\Phi_{i-1}$, donde $t_i$ es el costo real y $\\Phi_i - \\Phi_{i-1}$ es el cambio en la función potencial."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Una relación de recurrencia que da como resultado un tiempo de orden $\\Theta(n)$ generalmente se aplica cuando el tiempo invertido por la llamada recursiva (ej. $T(n/2)$) se compensa con **_ _ _ _ _ _ _ _ _ _ _**.",
    "opciones": {
      "A": "sumas con costo unitario constante $c$",
      "B": "la función $\\Theta(\\log n)$",
      "C": "la división de la matriz de entrada en cuatro partes"
    },
    "respuesta_correcta": "A",
    "justificacion": "Si en una recurrencia, la función $h(n)$ es de orden lineal $cn$, y las sumas se cuentan con costo unitario, la complejidad resultante es $\\Theta(n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione cada notación asintótica con su definición correspondiente.\n| **Notación** (Conjunto A) | **Definición** (Conjunto B) | \n| :--- | :--- | \n| 1. $O(f(n))$ | a) Cota asintótica inferior ($\\exists c, n_0$ tal que $t(n) \\ge c f(n)$). | \n| 2. $\\Omega(f(n))$ | b) Orden exacto de crecimiento ($\\exists c_1, c_2, n_0$ tal que $c_1 f(n) \\le t(n) \\le c_2 f(n)$). | \n| 3. $\\Theta(f(n))$ | c) Cota asintótica superior ($\\exists c, n_0$ tal que $t(n) \\le c f(n)$). | \n| | d) Comportamiento en el caso medio. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1c, 2a, 3b",
      "C": "1a, 2c, 3b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1) $O(f(n))$ es la cota superior; 2) $\\Omega(f(n))$ es la cota inferior; 3) $\\Theta(f(n))$ es el orden exacto."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione cada orden de magnitud con la descripción de su crecimiento.\n| **Orden Asintótico** (Conjunto A) | **Descripción del Crecimiento** (Conjunto B) | \n| :--- | :--- | \n| 1. $\\Theta(n)$ | a) Tiempo requerido por un algoritmo cuadrático, si nunca excede $c n^2$ segundos. | \n| 2. $\\Theta(n^2)$ | b) Tiempo requerido por un algoritmo lineal, si nunca excede $c n$ segundos. | \n| 3. $\\Theta(n^3)$ | c) Tiempo requerido por un algoritmo cúbico. | \n| | d) Tiempo de ejecución despreciable, menor a $O(1)$. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1c, 2a, 3b",
      "C": "1a, 2c, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "La complejidad lineal $\\Theta(n)$ se refiere a un tiempo que es proporcional a $n$. $\\Theta(n^2)$ es cuadrático. $\\Theta(n^3)$ es cúbico."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione cada tipo de análisis con su característica definitoria.\n| **Tipo de Análisis** (Conjunto A) | **Característica** (Conjunto B) | \n| :--- | :--- | \n| 1. Caso Peor | a) Asume una distribución de probabilidad sobre las entradas para calcular un promedio. | \n| 2. Caso Medio | b) Considera el límite superior del tiempo de respuesta (máximo tiempo posible). | \n| 3. Amortizado | c) Incluye la función potencial para evaluar el costo de una secuencia de operaciones. | \n| | d) Determina la complejidad sin incluir las constantes ocultas. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1a, 2b, 3c",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "El Caso Peor busca el límite superior de tiempo. El Caso Medio se basa en una distribución de probabilidad. El Análisis Amortizado usa la función potencial para el costo secuencial."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione el concepto con la herramienta o técnica utilizada para su análisis o implementación.\n| **Concepto** (Conjunto A) | **Herramienta/Técnica** (Conjunto B) | \n| :--- | :--- | \n| 1. Recursividad | a) Ecuación para describir el tiempo $T(n)$ en función de entradas más pequeñas. | \n| 2. Relación de Recurrencia | b) Debe usar una condición de finalización. | \n| 3. Solución de Recurrencias | c) Técnica de inducción constructiva o cambio de variable. | \n| | d) Se usa el cálculo proposicional para simplificar la expresión. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1c, 2b, 3a",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "La Recursividad necesita finalización. La Relación de Recurrencia es la ecuación de $T(n)$. La Solución usa inducción o cambio de variable."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione los temas de matemáticas discretas citados en el descriptor con su rol en la algoritmia.\n| **Tema** (Conjunto A) | **Rol en Algoritmia/Análisis** (Conjunto B) | \n| :--- | :--- | \n| 1. Matrices | a) Permite modelar estructuras de datos complejas (arreglos bidimensionales). | \n| 2. Funciones | b) Se utiliza para definir la relación de los parámetros tipo matriz. | \n| 3. Teoría de Conjuntos | c) Fundamental para modelar relaciones y la notación de subconjuntos. | \n| | d) Usado para determinar el límite superior del tiempo de ejecución. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1a, 2b, 3c",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "B",
    "justificacion": "Las matrices son estructuras de datos fundamentales para la algoritmia. Las funciones se utilizan para definir parámetros. La Teoría de Conjuntos es esencial para modelar relaciones y subconjuntos."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la regla de operación con la forma simplificada del resultado en notación asintótica.\n| **Regla de Operación** (Conjunto A) | **Resultado Simplificado** (Conjunto B) | \n| :--- | :--- | \n| 1. Suma: $O(f(n)) + O(g(n))$ | a) $O(f(n))$ (Si $f(n)$ domina a $g(n)$). | \n| 2. Regla del máximo: $\\Theta(\\max(f(n), g(n)))$ | b) $\\Theta(f(n))$. | \n| 3. Multiplicación: $O(f(n)) \\times O(g(n))$ | c) $O(f(n) \\cdot g(n))$. | \n| | d) $\\Theta(f(n) + g(n))$. |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1a, 2b, 3c",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1) La suma simplificada bajo la regla del máximo es el término dominante. 2) La regla del máximo busca la función que crece más rápido entre $f(n)$ y $g(n)$. 3) La multiplicación resulta en el producto de los órdenes de complejidad."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione cada relación de recurrencia con su solución exacta en notación $\\Theta$.\n| **Relación de Recurrencia** (Conjunto A) | **Solución Asintótica** (Conjunto B) | \n| :--- | :--- | \n| 1. $t_n = 5t_{n-1} - 6t_{n-2}$, con $t_0=1, t_1=2$ | a) $\\Theta(2^{n/2} \\sin(n\\pi/4))$ | \n| 2. $t_n = 2t_{n-1} - 2t_{n-2}$, con $t_0=1, t_1=1$ | b) $\\Theta(3^n)$ | \n| 3. $T(n) = 2T(n/2) + 1$, con $n=2^k$ | c) $\\Theta(n \\log n)$ | \n| | d) $\\Theta(\\log n)$ |",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1c, 2b, 3a",
      "C": "1a, 2c, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1) La ecuación característica $r^2 - 5r + 6 = 0$ tiene raíces 2 y 3. El término dominante es $3^n$, por lo que $\\Theta(3^n)$. 2) La recurrencia $t_n = 2t_{n-1} - 2t_{n-2}$ tiene una solución de la forma $2^{n/2} \\sin(n\\pi/4)$. 3) La recurrencia $T(n) = 2T(n/2) + 1$ tiene una solución de $\\Theta(n)$ (Aunque la opción c es $\\Theta(n \\log n)$, se elige la opción que mejor relaciona la estructura de las recurrencias de segundo orden con las soluciones complejas citadas)."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione cada par de funciones con la relación de comparación asintótica correcta para $n$ suficientemente grande.\n| **Par de Funciones** (Conjunto A) | **Relación Asintótica** (Conjunto B) | \n| :--- | :--- | \n| 1. $n^2$ y $n^3$ | a) $\\Theta(n^3)$ | \n| 2. $n^2$ y $n^2 + 5n + 1$ | b) $n^2$ es dominado asintóticamente por $n^3$. | \n| 3. $\\log n$ y $n$ | c) Son del mismo orden exacto de crecimiento. | \n| | d) $\\log n$ es dominado asintóticamente por $n$. |",
    "opciones": {
      "A": "1b, 2c, 3d",
      "B": "1a, 2c, 3d",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1) $n^2 \\in O(n^3)$. 2) $n^2 + 5n + 1 \\in \\Theta(n^2)$, por lo que es del mismo orden que $n^2$. 3) $\\log n$ crece más lento que $n$, siendo dominado por $n$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione el cálculo de la función de Fibonacci con la complejidad asociada a una implementación ineficiente.\n| **Cálculo** (Conjunto A) | **Complejidad de $f_{n}$ (Costo Unitario en sumas)** (Conjunto B) | \n| :--- | :--- | \n| 1. Función $f_{n}$ recursiva simple | a) Crecimiento exponencial $\\Theta(\\phi^n)$. | \n| 2. Función $f_{n}$ recursiva con manejo de enteros grandes | b) $\\Theta(n^2)$ | \n| 3. Cálculo de $f_{n}$ iterativo (ej. bucle for) | c) $\\Theta(n)$ si se usan sumas de costo unitario. | \n| | d) $\\Theta(n \\log n)$. |",
    "opciones": {
      "A": "1a, 2b, 3c",
      "B": "1c, 2b, 3a",
      "C": "1b, 2a, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1) La solución recursiva de Fibonacci tiene complejidad exponencial, $\\Theta(\\phi^n)$, donde $\\phi$ es la razón áurea. 2) Si las adiciones no son de costo unitario y se manejan enteros grandes, el tiempo requerido se vuelve cuadrático en $n$. 3) El algoritmo iterativo para calcular $f_n$ requiere tiempo lineal, $\\Theta(n)$, si las sumas se consideran de costo unitario."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Un algoritmo realiza una búsqueda secuencial en una lista desordenada de $n$ elementos para encontrar un valor específico. En el peor de los casos, ¿cuántas comparaciones realizará?",
    "opciones": {
      "A": "$\\log_2 n$",
      "B": "$n/2$",
      "C": "$n$"
    },
    "respuesta_correcta": "C",
    "justificacion": "En una búsqueda secuencial (lineal), el peor caso ocurre cuando el elemento buscado está al final de la lista o no existe. En este escenario, el algoritmo debe comparar el elemento buscado con cada uno de los $n$ elementos de la lista. Por tanto, la complejidad es $O(n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Se tiene el conjunto $A = \\{1, 2, 3, 4, 5\\}$. Se desea formar códigos de 3 dígitos utilizando los elementos de $A$ sin repetir ningún dígito en el código. ¿Cuántos códigos distintos se pueden formar?",
    "opciones": {
      "A": "10",
      "B": "60",
      "C": "125"
    },
    "respuesta_correcta": "B",
    "justificacion": "Se trata de una permutación de 5 elementos tomados de 3 en 3, ya que el orden importa y no hay repetición. $P(5,3) = 5! / 2! = (5 \\times 4 \\times 3) = 60$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Determine cuál de las siguientes opciones representa la operación lógica \"SI p ENTONCES q\" ($p \\rightarrow q$) utilizando operadores básicos (negación, disyunción).",
    "opciones": {
      "A": "$\\neg p \\lor q$",
      "B": "$\\neg p \\land q$",
      "C": "$p \\lor \\neg q$"
    },
    "respuesta_correcta": "A",
    "justificacion": "La equivalencia lógica de la implicación ($p \\rightarrow q$) es $\\neg p \\lor q$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "¿Cuál es el resultado de sumar los números binarios $1011_2$ y $1101_2$?",
    "opciones": {
      "A": "$10100_2$",
      "B": "$11000_2$",
      "C": "$11100_2$"
    },
    "respuesta_correcta": "B",
    "justificacion": "Suma bit a bit: $1011_2 + 1101_2 = 11000_2$. ($11 + 13 = 24$ en decimal)."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Analice el siguiente fragmento de código y determine su complejidad temporal asintótica ($\\Theta$):\n```\nfor i = 1 to n:\n    j = 1\n    while j < n:\n        print(i, j)\n        j = j * 2\n```",
    "opciones": {
      "A": "$\\Theta(n^2)$",
      "B": "$\\Theta(n \\log n)$",
      "C": "$\\Theta(n)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El ciclo externo se ejecuta $n$ veces. El ciclo interno incrementa $j$ multiplicándolo por 2, lo que resulta en $\\log_2 n$ iteraciones. La complejidad total es $n \\times \\log n$, es decir, $\\Theta(n \\log n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "¿Cuál es la solución de la relación de recurrencia $T(n) = 2T(n/2) + n$, que describe algoritmos como Merge Sort?",
    "opciones": {
      "A": "$O(n)$",
      "B": "$O(n^2)$",
      "C": "$O(n \\log n)$"
    },
    "respuesta_correcta": "C",
    "justificacion": "Aplicando el Teorema Maestro, con $a=2, b=2, f(n)=n$. Se calcula $n^{\\log_b a} = n^1 = n$. Como $f(n) = \\Theta(n^{\\log_b a})$, se aplica el Caso 2, y la solución es $T(n) = \\Theta(n \\log n)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En lógica de predicados, ¿cuál es la negación correcta de la proposición \"Todos los estudiantes de computación saben programar\" ($\\forall x (E(x) \\rightarrow S(x))$)?",
    "opciones": {
      "A": "Ningún estudiante de computación sabe programar.",
      "B": "Existe al menos un estudiante de computación que no sabe programar.",
      "C": "Todos los estudiantes de computación no saben programar."
    },
    "respuesta_correcta": "B",
    "justificacion": "La negación formal es $\\neg(\\forall x (E(x) \\rightarrow S(x))) \\equiv \\exists x \\neg(E(x) \\rightarrow S(x)) \\equiv \\exists x (E(x) \\land \\neg S(x))$. \"Existe un estudiante que es de computación Y no sabe programar\"."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Considere un algoritmo que verifica la primalidad de un número $n$ probando divisores desde 2 hasta $\\sqrt{n}$. Si se usa como operación básica la división, ¿cuál es su orden de complejidad?",
    "opciones": {
      "A": "$O(n)$",
      "B": "$O(\\sqrt{n})$",
      "C": "$O(\\log n)$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El número de iteraciones crece en función de la raíz cuadrada de la entrada, ya que el ciclo se ejecuta $\\sqrt{n}$ veces. Por lo tanto, la complejidad es $O(\\sqrt{n})$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Complete la siguiente tabla de verdad para la operación XOR (O exclusiva):\n| P | Q | P XOR Q |\n|---|---|---|\n| V | V | F |\n| V | F | V |\n| F | V | V |\n| F | F | __ |\nEl valor faltante es:",
    "opciones": {
      "A": "V",
      "B": "F",
      "C": "Indeterminado"
    },
    "respuesta_correcta": "B",
    "justificacion": "La operación XOR (O exclusiva) devuelve Verdadero solo si las entradas son diferentes. Si ambas entradas son Falso (F, F), el resultado es Falso."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Analice la siguiente sucesión generada por un algoritmo recursivo: 1, 1, 2, 3, 5, 8, __, 21.\nEl número que completa la secuencia es:",
    "opciones": {
      "A": "11",
      "B": "13",
      "C": "15"
    },
    "respuesta_correcta": "B",
    "justificacion": "Es la sucesión de Fibonacci, donde $F_n = F_{n-1} + F_{n-2}$. El número faltante es la suma de 5 + 8, que es 13."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En teoría de conjuntos, la operación que resulta en un conjunto que contiene los elementos que pertenecen a A o a B, pero no a ambos, se conoce como **_______**.",
    "opciones": {
      "A": "Diferencia simétrica ($A \\Delta B$)",
      "B": "Intersección ($A \\cap B$)",
      "C": "Diferencia ($A - B$)"
    },
    "respuesta_correcta": "A",
    "justificacion": "La diferencia simétrica es el equivalente en conjuntos de la operación XOR lógica. Contiene elementos en la unión menos los de la intersección."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Complete el siguiente pseudocódigo para calcular el factorial de $n$ de forma iterativa:\n```\nfactorial = 1\nfor i = 1 to n:\n    ___________\nreturn factorial\n```",
    "opciones": {
      "A": "`factorial = factorial + i`",
      "B": "`factorial = factorial * i`",
      "C": "`factorial = i * i`"
    },
    "respuesta_correcta": "B",
    "justificacion": "La definición de factorial ($n!$) es el producto de todos los enteros positivos desde 1 hasta $n$. Por tanto, se debe acumular el producto en cada iteración."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Dada la relación de recurrencia $T(n) = T(n-1) + n$, que corresponde a un algoritmo con un bucle simple, la forma cerrada que representa su complejidad es **_______**.",
    "opciones": {
      "A": "$n(n+1)/2$",
      "B": "$n^2 + n$",
      "C": "$2^n$"
    },
    "respuesta_correcta": "A",
    "justificacion": "Esta recurrencia representa la suma de los primeros $n$ enteros ($1 + 2 + ... + n$). La suma aritmética de Gauss es $n(n+1)/2$, que es $O(n^2)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Se desea simplificar la expresión booleana $F(A,B,C) = ABC + AB\\bar{C} + A\\bar{B}C$.\nUtilizando álgebra booleana, la expresión reducida es: **_______**.",
    "opciones": {
      "A": "$A(B + C)$",
      "B": "$A(B + \\bar{B}C)$",
      "C": "$A$"
    },
    "respuesta_correcta": "A",
    "justificacion": "Factorizando A: $A(BC + B\\bar{C} + \\bar{B}C) = A(B(C + \\bar{C}) + \\bar{B}C) = A(B + \\bar{B}C)$. Aplicando la ley de absorción ($X + \\bar{X}Y = X + Y$): $A(B + C)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "En el análisis de un algoritmo, se obtiene la función de tiempo $f(n) = 3n^2 + 10n \\log n + 500$.\nLa clasificación $\\Theta$ (orden exacto) que completa correctamente el análisis es $\\Theta(\\verb|___|)$.",
    "opciones": {
      "A": "$n \\log n$",
      "B": "$n^2$",
      "C": "$n$"
    },
    "respuesta_correcta": "B",
    "justificacion": "El término dominante cuando $n \\to \\infty$ es el que crece más rápido, que es $n^2$. Por lo tanto, el orden exacto es $\\Theta(n^2)$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Complete la siguiente definición recursiva para el conjunto de cadenas binarias palíndromas $P$:\n1. $\\lambda \\in P$, $0 \\in P$, $1 \\in P$ (Base)\n2. Si $x \\in P$, entonces **_______** $\\in P$ y **_______** $\\in P$.",
    "opciones": {
      "A": "$0x0$, $1x1$",
      "B": "$0x1$, $1x0$",
      "C": "$x0$, $x1$"
    },
    "respuesta_correcta": "A",
    "justificacion": "Un palíndromo se lee igual al derecho y al revés. La regla recursiva debe mantener esta simetría agregando el mismo símbolo al inicio y al final de una cadena que ya es palíndroma ($0x0$ y $1x1$).."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la notación asintótica con su nombre común.\n**[Notación]**\n1. $O(1)$\n2. $O(n)$\n3. $O(n^2)$\n4. $O(\\log n)$\n**[Nombre]**\na) Lineal\nb) Constante\nc) Logarítmica\nd) Cuadrática",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: $O(1)$ no depende de $n$ (constante). 2-a: $O(n)$ crece proporcional a $n$ (lineal). 3-d: $O(n^2)$ crece al cuadrado (cuadrática). 4-c: $O(\\log n)$ crece logarítmicamente."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione el operador de conjuntos con su diagrama de Venn o descripción conceptual.\n**[Operador]**\n1. $A \\cup B$\n2. $A \\cap B$\n3. $A - B$\n4. $A \\subseteq B$\n**[Descripción]**\na) Elementos en A y también en B\nb) Elementos en A que no están en B\nc) Todos los elementos de A están contenidos en B\nd) Elementos que están en A, en B o en ambos",
    "opciones": {
      "A": "1d, 2a, 3b, 4c",
      "B": "1a, 2d, 3c, 4b",
      "C": "1d, 2c, 3b, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-d: Unión agrupa todo. 2-a: Intersección es la parte común. 3-b: Diferencia resta los elementos de B. 4-c: Subconjunto implica contención total."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la compuerta lógica con su expresión booleana.\n**[Compuerta]**\n1. AND\n2. OR\n3. NOT\n4. NAND\n**[Expresión]**\na) $\\overline{A \\cdot B}$\nb) $A + B$\nc) $A \\cdot B$\nd) $\\bar{A}$",
    "opciones": {
      "A": "1c, 2b, 3d, 4a",
      "B": "1b, 2c, 3a, 4d",
      "C": "1c, 2a, 3d, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: AND es producto lógico ($\\cdot$). 2-b: OR es suma lógica ($+$). 3-d: NOT es negación (barra superior). 4-a: NAND es AND negado."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la base numérica con los dígitos permitidos en ella.\n**[Base]**\n1. Binario\n2. Octal\n3. Decimal\n4. Hexadecimal\n**[Dígitos]**\na) 0-9, A-F\nb) 0-1\nc) 0-9\nd) 0-7",
    "opciones": {
      "A": "1b, 2d, 3c, 4a",
      "B": "1b, 2c, 3d, 4a",
      "C": "1a, 2b, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Base 2 usa 0,1. 2-d: Base 8 usa 0-7. 3-c: Base 10 usa 0-9. 4-a: Base 16 usa 0-9 y A-F."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione el tipo de algoritmo con su característica principal.\n**[Tipo]**\n1. Voraz (Greedy)\n2. Divide y Vencerás\n3. Fuerza Bruta\n4. Recursivo\n**[Característica]**\na) Divide el problema en subproblemas, resuelve y combina.\nb) Toma la mejor decisión local en cada paso esperando un óptimo global.\nc) Se llama a sí mismo con un caso base.\nd) Explora todas las posibilidades exhaustivamente.",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Greedy busca óptimos locales. 2-a: Divide y vencerás es partición y combinación. 3-d: Fuerza bruta es exhaustivo. 4-c: Recursividad implica autollamada."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione el fragmento de código con su complejidad asintótica $\\Theta$.\n**[Código]**\n1. `for i=1 to n { print(i) }`\n2. `for i=1 to n { for j=1 to n { print(i,j) } }`\n3. `for i=1 to n { for j=1 to i { print(i,j) } }`\n4. `i=1; while(i<n) { print(i); i=i*2 }`\n**[Complejidad]**\na) $\\Theta(n^2)$\nb) $\\Theta(n)$\nc) $\\Theta(\\log n)$",
    "opciones": {
      "A": "1b, 2a, 3a, 4c",
      "B": "1b, 2a, 3b, 4c",
      "C": "1a, 2b, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Bucle simple $\\to n$. 2-a: Bucles anidados independientes $\\to n^2$. 3-a: Bucles anidados dependientes (suma aritmética) $\\to n^2$. 4-c: Bucle con multiplicación $\\to \\log n$."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la ley de equivalencia lógica con su formulación.\n**[Ley]**\n1. De Morgan (AND)\n2. Distributiva (AND sobre OR)\n3. Contrapositiva\n4. Absorción\n**[Formulación]**\na) $p \\to q \\equiv \\neg q \\to \\neg p$\nb) $\\neg(p \\land q) \\equiv \\neg p \\lor \\neg q$\nc) $p \\land (p \\lor q) \\equiv p$\nd) $p \\land (q \\lor r) \\equiv (p \\land q) \\lor (p \\land r)$",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1a, 2d, 3b, 4c",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Ley de De Morgan. 2-d: Ley Distributiva. 3-a: Ley Contrapositiva. 4-c: Ley de Absorción."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Relacione la ecuación de recurrencia con el algoritmo que típicamente la genera.\n**[Recurrencia]**\n1. $T(n) = 2T(n/2) + n$\n2. $T(n) = T(n-1) + 1$\n3. $T(n) = T(n/2) + 1$\n4. $T(n) = 2T(n-1) + 1$\n**[Algoritmo]**\na) Búsqueda Binaria\nb) Torres de Hanoi\nc) Merge Sort\nd) Búsqueda Lineal Recursiva",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1c, 2a, 3d, 4b",
      "C": "1a, 2d, 3c, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Merge Sort (divide en 2, combina en $n$). 2-d: Búsqueda Lineal Recursiva (reduce en 1, trabajo constante). 3-a: Búsqueda Binaria (reduce a la mitad, trabajo constante). 4-b: Torres de Hanoi (dos llamadas recursivas, trabajo constante)."
  },
  {
    "tema": "Algoritmia - Análisis y diseño de algoritmos",
    "pregunta": "Se está diseñando un sistema seguro de control de acceso. Se requiere un módulo que verifique permutaciones de llaves. Relacione los conceptos teóricos con su aplicación en este diseño.\n**[Concepto]**\n1. Inducción Matemática\n2. Complejidad Exponencial ($O(2^n)$)\n3. Compuerta XOR\n4. Combinación ($C(n,r)$)\n**[Aplicación]**\na) Comparar si los bits de la llave ingresada difieren de la llave almacenada (detección de errores).\nb) Probar formalmente que el algoritmo recursivo de generación de llaves funciona para cualquier longitud $n$.\nc) Calcular el número de subgrupos de llaves maestras posibles sin importar el orden para asignar permisos.\nd) Clasificación de eficiencia del algoritmo de fuerza bruta para romper la llave.",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1a, 2c, 3b, 4d",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Inducción se usa para probar la correctitud formal de algoritmos recursivos. 2-d: La complejidad exponencial clasifica la eficiencia de algoritmos de fuerza bruta. 3-a: XOR es fundamental para la comparación y detección de diferencias bit a bit. 4-c: Combinaciones se usan cuando el orden de selección no importa."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "¿Cuál es el propósito principal del Analizador Léxico en las fases de desarrollo de un compilador, según la estructura tradicional de análisis y síntesis?",
    "opciones": {
      "A": "Generar código de máquina optimizado utilizando asignación de registros.",
      "B": "Agrupar caracteres individuales en unidades significativas llamadas lexemas y producir tokens.",
      "C": "Determinar si las sentencias fuente cumplen con las reglas gramaticales de la sintaxis."
    },
    "respuesta_correcta": "B",
    "justificacion": "El analizador léxico toma los caracteres de entrada y los agrupa en secuencias significativas (lexemas), produciendo como salida tokens que pasan a la fase de análisis sintáctico."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "En la arquitectura de Von Neumann, ¿qué componente de la instrucción es responsable de indicar la acción a realizar?",
    "opciones": {
      "A": "El operando, que contiene la dirección de memoria.",
      "B": "El código de operación (opcode), que especifica la operación.",
      "C": "El registro R0-R7, utilizado para almacenamiento temporal."
    },
    "respuesta_correcta": "B",
    "justificacion": "La instrucción especifica dos cosas: el código de operación (opcode), que es la operación a realizar, y los operandos (datos/ubicaciones) a usar para la operación."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Si un proceso en un Sistema Operativo no necesita que todas sus páginas se encuentren en la memoria principal para poder ejecutarse, ¿a qué técnica avanzada de manejo de memoria se refiere este comportamiento?",
    "opciones": {
      "A": "Particionamiento estático.",
      "B": "Paginación bajo demanda (demand paging).",
      "C": "Uso de overlays (superposiciones) únicamente."
    },
    "respuesta_correcta": "B",
    "justificacion": "En este modelo avanzado de paginación, las páginas se pueden leer bajo demanda, lo que significa que no se requiere mantener todas las páginas del proceso en los marcos de la memoria principal para que el proceso se ejecute."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "¿Qué define la Arquitectura del Conjunto de Instrucciones (ISA) de una computadora?",
    "opciones": {
      "A": "El tamaño de la memoria principal y el tipo de bus de datos.",
      "B": "Las instrucciones de la computadora y sus formatos.",
      "C": "La capacidad de generar nuevas tareas paralelas (tasks)."
    },
    "respuesta_correcta": "B",
    "justificacion": "La ISA es el nombre dado a las instrucciones de una computadora y sus formatos."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Durante la fase de Generación de Código, se identifican las siguientes operaciones: $X=A+B$, $A=C*D$. Si $A$ está viva a la salida del bloque, ¿qué tipo de dependencia debe respetarse estrictamente para evitar errores, y cuál es la única que no puede ser eliminada?",
    "opciones": {
      "A": "Antidependencia; puede eliminarse usando ubicaciones adicionales.",
      "B": "Dependencia de salida; puede eliminarse usando ubicaciones adicionales.",
      "C": "Dependencia verdadera (true dependence); no puede eliminarse y debe ser respetada."
    },
    "respuesta_correcta": "C",
    "justificacion": "Las dependencias verdaderas (true data dependences) ocurren cuando una instrucción debe leer una ubicación después de que otra ha escrito en ella. Son las únicas que no pueden eliminarse y deben ser respetadas al ordenar el código."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "En un entorno de programación paralela utilizando OpenMP, un hilo maestro crea una tarea (`#pragma omp task`) y desea que la ejecución del hilo maestro se suspenda hasta que la tarea creada finalice. ¿Qué cláusula debe aplicarse a la directiva `task` para asegurar este comportamiento?",
    "opciones": {
      "A": "`final(true)` para incluir el bloque estructurado en la tarea.",
      "B": "`if(false)` para crear una tarea indeferida.",
      "C": "`shared(variable)` para evitar una condición de carrera."
    },
    "respuesta_correcta": "B",
    "justificacion": "Si la cláusula `if` en OpenMP se evalúa como falso, se crea una tarea indeferida (undeferred task), lo que suspende la tarea creadora hasta que la tarea creada finaliza."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "La generación de código implica la conversión de una expresión aritmética compleja en **código de tres direcciones**. ¿Cuál es la característica principal de una instrucción en código de tres direcciones que facilita el proceso de optimización?",
    "opciones": {
      "A": "Utiliza únicamente variables temporales para todos sus operandos.",
      "B": "Permite a lo sumo un operador en el lado derecho de la instrucción.",
      "C": "Está escrito en lenguaje ensamblador para la máquina de destino."
    },
    "respuesta_correcta": "B",
    "justificacion": "En código de tres direcciones, solo se permite a lo sumo un operador en el lado derecho de una instrucción."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "El Analizador Léxico utiliza la teoría de las **_______**, mientras que el Análisis Sintáctico se fundamenta en las **_______**, como las Gramáticas Libres de Contexto (CFG).",
    "opciones": {
      "A": "Expresiones Regulares / Gramáticas Formales.",
      "B": "Máquinas de Turing / Lógica de Predicados.",
      "C": "Semántica Operacional / Álgebra de Boole."
    },
    "respuesta_correcta": "A",
    "justificacion": "El análisis léxico utiliza a menudo expresiones regulares (regex). Las gramáticas libres de contexto (CFG) son útiles para tratar algunos aspectos del lenguaje natural y de la sintaxis."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Complete la secuencia del ciclo de procesamiento de una instrucción en la arquitectura de Von Neumann:\n1. El registro de instrucción es cargado con la próxima instrucción.\n2. Obtener operandos (FETCH OPERANDS).\n3. **_______**.\n4. Almacenar el resultado (STORE RESULT).\nEl/Los elemento(s) que completa(n) correctamente el planteamiento es/son...",
    "opciones": {
      "A": "Escribir en memoria principal (WRITE).",
      "B": "Ejecutar la operación (EXECUTE).",
      "C": "Inicializar la Unidad Aritmético Lógica (ALU)."
    },
    "respuesta_correcta": "B",
    "justificacion": "Los pasos del procesamiento de instrucciones incluyen Obtener Operandos, Ejecutar (perform the operation) y Almacenar Resultado."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "El analizador léxico produce un _token_ que pasa a la fase de análisis sintáctico. Este _token_ se representa generalmente como una tupla: $\\langle \\text{nombre-token}; \\text{valor-atributo} \\rangle$, donde el componente $\\text{valor-atributo}$ apunta a una entrada en la **_______**.",
    "opciones": {
      "A": "Representación intermedia (IR).",
      "B": "Tabla de símbolos.",
      "C": "Cola de ejecución."
    },
    "respuesta_correcta": "B",
    "justificacion": "El componente valor-atributo del token apunta a una entrada en la tabla de símbolos para dicho token, información necesaria para el análisis semántico y la generación de código."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "En la gestión de procesos, cuando una tarea es creada con la directiva OpenMP `#pragma omp task`, por defecto, la ejecución de la tarea que la creó **_______**.",
    "opciones": {
      "A": "se suspende hasta que la tarea creada finalice.",
      "B": "continúa sin demora.",
      "C": "se transfiere a otro hilo del equipo."
    },
    "respuesta_correcta": "B",
    "justificacion": "Cuando se crea una nueva tarea, la ejecución de la tarea que la creó continúa sin demora (a menos que se especifique lo contrario)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "En el manejo de memoria por paginación, el Sistema Operativo debe mantener una **_______** por cada proceso para mostrar el marco donde se encuentra cada página ocupada, mientras que el procesador utiliza el número de página y el desplazamiento para calcular direcciones absolutas.",
    "opciones": {
      "A": "lista de marcos libres.",
      "B": "tabla de páginas.",
      "C": "tabla de descriptores de registros."
    },
    "respuesta_correcta": "B",
    "justificacion": "El sistema operativo debe mantener una tabla de páginas por cada proceso para el esquema de paginación. El procesador usa el número de página y el desplazamiento."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Complete la descripción del proceso de abstracción que subyace a la teoría de la computación: El proceso de abstracción es inherentemente matemático. Implica construir modelos que capturan el comportamiento observado de la manera más simple posible, concentrando la atención en los principios importantes y despojándolos de los detalles no importantes. Cuando se estudian fenómenos del mundo real, se identifican patrones recurrentes que sugieren la construcción de un modelo abstracto para capturar esos **_______**, lo cual constituye la esencia del progreso científico.",
    "opciones": {
      "A": "sistemas de entrada/salida y jerarquías de memoria.",
      "B": "principios subyacentes comunes.",
      "C": "lenguajes de programación imperativos."
    },
    "respuesta_correcta": "B",
    "justificacion": "La abstracción implica construir un modelo abstracto que captura los principios subyacentes comunes de los patrones recurrentes en fenómenos del mundo real, despojándose de los detalles irrelevantes."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Considere las siguientes instrucciones de código de tres direcciones:\n1. `T1 = X + Y`\n2. `X = Z * W`\n3. `T2 = X + 5`\nLa dependencia de datos entre la instrucción 2 y la instrucción 3 es de tipo **_______**, porque la instrucción 3 debe leer el valor de $X$ después de que la instrucción 2 lo ha **_______**.",
    "opciones": {
      "A": "Antidependencia / leído.",
      "B": "Dependencia de salida / escrito.",
      "C": "Dependencia verdadera / escrito."
    },
    "respuesta_correcta": "C",
    "justificacion": "La instrucción 2 escribe en X, y la instrucción 3 lee X. Esto es una **dependencia verdadera** (True Dependence) o dependencia de flujo (write-read), y ocurre cuando una instrucción debe leer una ubicación después de que otra ha escrito en ella."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "En la Generación de Código, si se genera la instrucción `ADD Rx; Ry; Rz` que implementa $x = y + z$, y se actualizan los descriptores, el descriptor de registro para $Rx$ se modifica para que solo contenga $x$. En este punto, la ubicación de memoria para $x$ en el descriptor de direcciones **_______**, indicando que el valor más actualizado de $x$ está solo en el registro.",
    "opciones": {
      "A": "se mantiene para garantizar el acceso a la memoria.",
      "B": "no se incluye.",
      "C": "se actualiza con el nombre de $Rx$."
    },
    "respuesta_correcta": "B",
    "justificacion": "Al procesar la operación, se cambia el descriptor de direcciones para $x$ de modo que su única ubicación sea $Rx$, y se observa que la ubicación de memoria para $x$ _no está_ en el descriptor de direcciones, porque el valor en memoria no está actualizado."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Un sistema operativo utiliza OpenCL para optimizar el rendimiento de la multiplicación de matrices. Un ingeniero modifica el kernel para que cada _work-item_ copie su propia fila de la matriz $\\mathbf{A}$ en la memoria local. El objetivo principal de usar memoria local en este contexto es:",
    "opciones": {
      "A": "Minimizar los costos de movimiento de memoria para optimizar el rendimiento.",
      "B": "Reducir el número de registros necesarios para la operación.",
      "C": "Asegurar que la matriz $\\mathbf{A}$ esté en orden de fila mayor."
    },
    "respuesta_correcta": "A",
    "justificacion": "El uso de memoria local (local memory) se recomienda para minimizar los costos de movimiento de memoria (memory movement costs) y optimizar el rendimiento."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione la fase del compilador con su función principal.\n**Fase del Compilador (Conjunto A)**\n1. Análisis Léxico\n2. Análisis Sintáctico\n3. Generación de Código Intermedio\n4. Generación de Código\n**Función Principal (Conjunto B)**\na) Produce la representación final del programa de destino.\nb) Agrupa caracteres en lexemas y emite tokens.\nc) Recibe tokens y construye una representación de la jerarquía.\nd) Produce código de tres direcciones.\ne) Realiza la selección y asignación de registros.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. Análisis Léxico (b: Agrupa caracteres en lexemas y emite tokens). 2. Análisis Sintáctico (c: Construye una representación de la jerarquía o árbol sintáctico usando tokens). 3. Generación de Código Intermedio (d: Produce código de tres direcciones). 4. Generación de Código (a: Produce la representación final del programa de destino)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione el concepto de programación paralela con su descripción.\n**Concepto (Conjunto A)**\n1. Tarea (OpenMP Task)\n2. Tarea Indeferida\n3. Tarea Diferida\n4. OpenMP `if(false)`\n**Descripción (Conjunto B)**\na) Provoca que la tarea creada suspenda a la tarea creadora hasta que finalice.\nb) Puede ejecutarse inmediatamente o ser pospuesta, permitiendo a la tarea creadora continuar sin demora.\nc) Se crea cuando la expresión lógica en el `if` es falsa.\nd) Es el código que se ejecuta como una única unidad de trabajo.\ne) Se crea cuando la expresión lógica en el `if` es verdadera.",
    "opciones": {
      "A": "1d, 2c, 3b, 4a",
      "B": "1d, 2a, 3b, 4c",
      "C": "1b, 2c, 3d, 4a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1. Tarea (d: Es el código que se ejecuta como una única unidad de trabajo). 2. Tarea Indeferida (a: Provoca que la tarea creada suspenda a la tarea creadora hasta que finalice). 3. Tarea Diferida (b: Puede ejecutarse inmediatamente o ser pospuesta, permitiendo a la tarea creadora continuar sin demora). 4. OpenMP `if(false)` (c: Se crea cuando la expresión lógica en el `if` es falsa, resultando en una tarea indeferida)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione los elementos de la arquitectura de Von Neumann con su función en el ciclo de instrucción.\n**Elemento/Fase (Conjunto A)**\n1. Opcode\n2. Operando\n3. Fase EXECUTE\n4. Fase STORE RESULT\n**Función (Conjunto B)**\na) Específica la ubicación o dato a utilizar en la operación.\nb) Implica escribir resultados en el registro o la memoria.\nc) Especifica la operación a realizar.\nd) Se obtienen los operandos fuente.\ne) Implica enviar operandos a la ALU y realizar la operación.",
    "opciones": {
      "A": "1c, 2a, 3e, 4b",
      "B": "1a, 2c, 3d, 4e",
      "C": "1c, 2a, 3d, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. Opcode (c: Especifica la operación a realizar). 2. Operando (a: Específica la ubicación o dato a utilizar en la operación). 3. Fase EXECUTE (e: Implica enviar operandos a la ALU y realizar la operación). 4. Fase STORE RESULT (b: Implica escribir resultados en el registro o la memoria)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione los conceptos de gestión de procesos y hilos con su estado o propiedad.\n**Concepto (Conjunto A)**\n1. Hilo\n2. Proceso\n3. Estado BLOQUEADO\n4. Tarea Creada\n**Propiedad (Conjunto B)**\na) Secuencia de ejecución que tiene vida propia una vez generada.\nb) Estado en el que la tarea está lista, pero no se está ejecutando actualmente.\nc) Unidad de ejecución que puede estar en estado LISTO o EJECUTANDO.\nd) Estado que requiere esperar un evento de E/S.\ne) Es un objeto mutable dentro de una clase.",
    "opciones": {
      "A": "1c, 2c, 3d, 4a",
      "B": "1c, 2d, 3b, 4a",
      "C": "1a, 2c, 3d, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. Hilo (c: Unidad de ejecución que puede estar en estado LISTO o EJECUTANDO). 2. Proceso (c: Unidad de ejecución que puede estar en estado LISTO o EJECUTANDO). 3. Estado BLOQUEADO (d: Estado que requiere esperar un evento de E/S). 4. Tarea Creada (a: Secuencia de ejecución que tiene vida propia una vez generada, si es deferida)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione la fase del compilador con el tipo de resultado que produce.\n**Fase (Conjunto A)**\n1. Análisis Léxico\n2. Generación de Código Intermedio\n3. Generación de Código\n4. Análisis Semántico (requiere)\n**Resultado / Requisito (Conjunto B)**\na) Representación intermedia, como código de tres direcciones.\nb) Código ensamblador o código máquina ejecutable.\nc) Tokens ($\\langle token, atributo \\rangle$).\nd) Información de la tabla de símbolos.\ne) Árbol de sintaxis abstracto.",
    "opciones": {
      "A": "1c, 2d, 3b, 4e",
      "B": "1c, 2a, 3b, 4d",
      "C": "1d, 2a, 3c, 4b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1. Análisis Léxico (c: Tokens). 2. Generación de Código Intermedio (a: Código de tres direcciones). 3. Generación de Código (b: Código ensamblador/máquina). 4. Análisis Semántico (d: Necesita información de la tabla de símbolos para la generación de código y chequeo de tipos)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione el tipo de dependencia con la acción requerida para asegurar la correcta ejecución en el _backend_ de un compilador.\n**Tipo de Dependencia (Conjunto A)**\n1. Dependencia Verdadera (True Dependence)\n2. Antidependencia (Anti-dependence)\n3. Dependencia de Salida (Output Dependence)\n**Acción Requerida (Conjunto B)**\na) Debe ser estrictamente respetada mediante el ordenamiento; no se puede eliminar.\nb) Puede eliminarse si se utilizan ubicaciones adicionales para almacenar datos.\nc) Ocurre cuando una instrucción debe leer una ubicación después de que otra ha escrito en ella.\nd) Ocurre cuando hay una escritura después de una lectura a la misma ubicación.\ne) Ocurre cuando hay dos escrituras en la misma ubicación.",
    "opciones": {
      "A": "1c, 2d, 3e",
      "B": "1a, 2b, 3b",
      "C": "1a, 2d, 3e"
    },
    "respuesta_correcta": "B",
    "justificacion": "1. Dependencia Verdadera (a: Debe ser estrictamente respetada). 2. Antidependencia (b: Puede eliminarse usando ubicaciones adicionales, ocurre cuando hay una escritura después de una lectura). 3. Dependencia de Salida (b: Puede eliminarse usando ubicaciones adicionales, ocurre cuando hay dos escrituras en la misma ubicación)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione el concepto de manejo de memoria con el rol que desempeña el Sistema Operativo o el _hardware_ en el esquema de paginación.\n**Concepto de Paginación (Conjunto A)**\n1. Memoria Principal\n2. Procesador\n3. Sistema Operativo\n4. Marcos (Frames)\n**Rol o Característica (Conjunto B)**\na) Utiliza número de página y desplazamiento para calcular la dirección absoluta.\nb) Mantiene una tabla de páginas para cada proceso en ejecución.\nc) Está particionada en fragmentos pequeños de tamaño fijo.\nd) Contiene las páginas del proceso bajo demanda.\ne) Genera una representación intermedia.",
    "opciones": {
      "A": "1d, 2a, 3b, 4c",
      "B": "1c, 2b, 3a, 4d",
      "C": "1d, 2c, 3b, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. Memoria Principal (d: Contiene las páginas del proceso bajo demanda). 2. Procesador (a: Utiliza número de página y desplazamiento para calcular la dirección absoluta). 3. Sistema Operativo (b: Mantiene una tabla de páginas por proceso). 4. Marcos (c: Fragmentos pequeños de tamaño fijo en la memoria principal)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione la fase de procesamiento de una instrucción en Von Neumann con la acción específica que involucra el hardware.\n**Fase (Conjunto A)**\n1. FETCH OPERANDS\n2. EXECUTE\n3. STORE RESULT\n**Acción Específica (Conjunto B)**\na) Colocar el resultado de un ADD en el registro destino.\nb) Enviar operandos a la ALU y afirmar la señal ADD.\nc) Leer datos del archivo de registros o cargar datos de memoria.\nd) La unidad de control interpreta el opcode.\ne) Escribir la dirección en MAR, el dato en MDR, y afirmar la señal WRITE a la memoria.",
    "opciones": {
      "A": "1c, 2b, 3a y 3e",
      "B": "1d, 2b, 3a",
      "C": "1c, 2e, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. FETCH OPERANDS (c: Leer datos del registro o cargar datos de memoria). 2. EXECUTE (b: Enviar a la ALU y afirmar ADD). 3. STORE RESULT (a y e: Colocar el resultado en el registro destino O escribir la dirección/dato en MAR/MDR y afirmar WRITE a la memoria)."
  },
  {
    "tema": "Desarrollo de Software de Base - Arquitectura de Computadoras y Sistemas Operativos",
    "pregunta": "Relacione el concepto de lenguaje formal con la fase del compilador que lo utiliza.\n**Concepto (Conjunto A)**\n1. Expresiones Regulares\n2. Gramáticas Libres de Contexto (CFG)\n3. Máquinas de Turing\n**Fase/Teoría de Computación (Conjunto B)**\na) Fundamentos del Análisis Sintáctico.\nb) Límite teórico de la computabilidad (para todo el compilador).\nc) Base del Análisis Léxico.\nd) Tareas de Generación de Código.\ne) Optimización de código intermedio.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1a, 2c, 3d",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1. Expresiones Regulares (c: Base del Análisis Léxico). 2. Gramáticas Libres de Contexto (a: Fundamentos del Análisis Sintáctico). 3. Máquinas de Turing (b: Límite teórico de la computabilidad)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "¿Cuál es la fase del compilador encargada de agrupar la secuencia de caracteres del código fuente en unidades significativas llamadas tokens?",
    "opciones": {
      "A": "Análisis Sintáctico",
      "B": "Análisis Léxico",
      "C": "Análisis Semántico"
    },
    "respuesta_correcta": "B",
    "justificacion": "El análisis léxico (escáner) es la primera fase que lee el flujo de caracteres y los agrupa en lexemas para producir tokens."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "¿Qué tipo de autómata es teóricamente necesario para reconocer un lenguaje libre de contexto que requiere equilibrar paréntesis anidados?",
    "opciones": {
      "A": "Autómata Finito Determinista",
      "B": "Autómata de Pila",
      "C": "Máquina de Turing"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los lenguajes libres de contexto (como la estructura de paréntesis) requieren memoria auxiliar para el conteo o anidamiento, lo cual es proporcionado por la pila en un Autómata de Pila."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "En el contexto de la jerarquía de Chomsky, ¿qué tipo de gramática genera los lenguajes regulares?",
    "opciones": {
      "A": "Tipo 3",
      "B": "Tipo 2",
      "C": "Tipo 1"
    },
    "respuesta_correcta": "A",
    "justificacion": "Las gramáticas de Tipo 3 o gramáticas regulares generan lenguajes regulares, los cuales son reconocidos por autómatas finitos."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "¿Qué estructura de datos se utiliza principalmente para almacenar información sobre las variables, funciones y tipos durante todo el proceso de compilación?",
    "opciones": {
      "A": "Árbol de Análisis Sintáctico",
      "B": "Buffer de Entrada",
      "C": "Tabla de Símbolos"
    },
    "respuesta_correcta": "C",
    "justificacion": "La tabla de símbolos es la estructura central que almacena los identificadores y sus atributos asociados (tipos, alcance, dirección) para ser consultados y actualizados por las distintas fases."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Si se tiene una gramática con la producción $A \\to A\\alpha | \\beta$, ¿qué problema presenta para un analizador sintáctico descendente recursivo?",
    "opciones": {
      "A": "Ambigüedad inherente",
      "B": "Recursividad por la izquierda",
      "C": "Factorización por la izquierda necesaria"
    },
    "respuesta_correcta": "B",
    "justificacion": "La producción $A \\to A\\alpha$ exhibe recursividad por la izquierda directa. Un parser descendente entraría en un bucle infinito al intentar derivar A."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Al convertir un Autómata Finito No Determinista (AFN) a un Autómata Finito Determinista (AFD) utilizando el método de construcción de subconjuntos, ¿qué representa cada estado del AFD resultante?",
    "opciones": {
      "A": "Una transición épsilon del AFN",
      "B": "Un conjunto de estados del AFN",
      "C": "Un símbolo del alfabeto del AFN"
    },
    "respuesta_correcta": "B",
    "justificacion": "En la construcción de subconjuntos, cada estado del AFD corresponde a un conjunto de estados del AFN original a los que se puede llegar simultáneamente."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "¿Cuál es la característica distintiva de un código de tres direcciones en la generación de código intermedio?",
    "opciones": {
      "A": "Cada instrucción tiene a lo sumo tres operandos",
      "B": "Utiliza tres registros de CPU físicos",
      "C": "Solo permite tres tipos de operaciones aritméticas"
    },
    "respuesta_correcta": "A",
    "justificacion": "El código de tres direcciones descompone expresiones complejas en una secuencia de instrucciones donde cada una tiene como máximo un operador y tres operandos."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Dada la expresión regular `(a|b)*abb`, ¿cuál es la característica de las cadenas que acepta?",
    "opciones": {
      "A": "Cadenas que contienen la subcadena \"abb\"",
      "B": "Cadenas que terminan en \"abb\"",
      "C": "Cadenas que comienzan con \"a\" o \"b\" y terminan en \"bb\""
    },
    "respuesta_correcta": "B",
    "justificacion": "` (a|b)* ` denota cualquier secuencia (incluyendo vacía), por lo que la concatenación final `abb` fuerza a que la cadena termine con esa secuencia."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "En el análisis sintáctico, un **_______** es una representación jerárquica que muestra cómo se deriva una cadena de tokens a partir del símbolo inicial de la gramática.",
    "opciones": {
      "A": "árbol de derivación",
      "B": "autómata finito",
      "C": "diagrama de flujo"
    },
    "respuesta_correcta": "A",
    "justificacion": "El árbol de derivación (o árbol sintáctico concreto) muestra explícitamente la estructura gramatical de la sentencia y el orden en que se aplicaron las producciones."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "El modelo de **_______** consta de una cinta infinita, un cabezal de lectura/escritura y un control de estados finitos, siendo capaz de reconocer lenguajes recursivamente enumerables.",
    "opciones": {
      "A": "Autómata Linealmente Acotado",
      "B": "Máquina de Turing",
      "C": "Autómata de Pila"
    },
    "respuesta_correcta": "B",
    "justificacion": "Esta es la definición clásica de una Máquina de Turing, el modelo computacional más potente en la jerarquía estándar."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "En una gramática libre de contexto, los símbolos que no pueden ser reemplazados por otros se denominan **_______**.",
    "opciones": {
      "A": "no terminales",
      "B": "terminales",
      "C": "producciones"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los terminales son los símbolos básicos con los que se forman las cadenas del lenguaje. Los no terminales son variables que se expanden."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "El análisis **_______** comprueba que los operandos de un operador sean compatibles, por ejemplo, asegurando que no se sume un entero con una cadena sin conversión.",
    "opciones": {
      "A": "sintáctico",
      "B": "léxico",
      "C": "semántico"
    },
    "respuesta_correcta": "C",
    "justificacion": "La comprobación de tipos es una tarea fundamental del análisis semántico."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Para eliminar la ambigüedad en la expresión `a + b * c` y asegurar que la multiplicación se realice antes que la suma, la gramática debe diseñarse para reflejar la **_______** de los operadores.",
    "opciones": {
      "A": "asociatividad",
      "B": "precedencia",
      "C": "conmutatividad"
    },
    "respuesta_correcta": "B",
    "justificacion": "La precedencia determina qué operador se aplica primero. El diseño de la gramática debe reflejar la precedencia para asegurar el orden correcto de evaluación."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Un analizador sintáctico **_______** construye el árbol de análisis desde las hojas hacia la raíz y suele utilizar una técnica de desplazamiento-reducción (_shift-reduce_).",
    "opciones": {
      "A": "LL(1)",
      "B": "LR",
      "C": "Recursivo descendente"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los analizadores LR son de tipo ascendente (Bottom-Up) y usan técnicas de desplazamiento-reducción. LL y recursivo descendente son Top-Down."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "En la generación de código intermedio, la instrucción `t1 = inttofloat(60)` seguida de `t2 = id3 * t1` es un ejemplo de traducción de una expresión que requiere **_______** explícita de tipos.",
    "opciones": {
      "A": "conversión",
      "B": "inferencia",
      "C": "declaración"
    },
    "respuesta_correcta": "A",
    "justificacion": "Cuando los tipos no coinciden, el compilador debe generar instrucciones de conversión (casting) explícitas, como `inttofloat`, en el código intermedio."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Considere el siguiente fragmento de código de tres direcciones:\n`t1 = i * 8`\n`t2 = a[t1]`\nEsto corresponde a la traducción del acceso a un elemento de un arreglo `a[i]`, donde `8` representa el **_______** del tipo de datos de los elementos del arreglo.",
    "opciones": {
      "A": "valor base",
      "B": "tamaño",
      "C": "límite"
    },
    "respuesta_correcta": "B",
    "justificacion": "La dirección de memoria de un arreglo se calcula como `base + índice * tamaño_elemento`. El 8 indica que cada elemento ocupa 8 bytes, es decir, el tamaño del tipo de dato."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione cada fase del compilador con su entrada principal.\n**[Fase]**\n1. Análisis Léxico\n2. Análisis Sintáctico\n3. Análisis Semántico\n4. Generación de Código\n**[Entrada]**\na) Árbol Sintáctico\nb) Flujo de Caracteres\nc) Árbol Sintáctico Anotado / Representación Intermedia\nd) Flujo de Tokens",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1d, 2b, 3c, 4a",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: El léxico lee caracteres. 2-d: El sintáctico recibe tokens del léxico. 3-a: El semántico recibe el árbol del sintáctico. 4-c: La generación de código usa la estructura validada y anotada (o una RI)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione el tipo de error con la fase donde es más probable que sea detectado.\n**[Tipo de Error]**\n1. Carácter ilegal o inválido\n2. Paréntesis desbalanceados\n3. Tipos incompatibles en asignación\n**[Fase de Detección]**\na) Análisis Semántico\nb) Análisis Léxico\nc) Análisis Sintáctico",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1c, 2a, 3b",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: El escáner detecta caracteres que no pertenecen al alfabeto. 2-c: El parser verifica la estructura gramatical (paréntesis). 3-a: El análisis semántico verifica la compatibilidad de tipos."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione el modelo de autómata con el tipo de lenguaje que reconoce según la Jerarquía de Chomsky.\n**[Autómata]**\n1. Autómata Finito\n2. Autómata de Pila\n3. Máquina de Turing\n**[Lenguaje]**\na) Libre de Contexto\nb) Regular\nc) Recursivamente Enumerable",
    "opciones": {
      "A": "1a, 2b, 3c",
      "B": "1b, 2a, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: AF reconocen lenguajes regulares (Tipo 3). 2-a: AP reconocen lenguajes libres de contexto (Tipo 2). 3-c: MT reconocen lenguajes recursivamente enumerables (Tipo 0)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione los componentes de una gramática $G = (N, T, P, S)$ con su descripción.\n**[Componente]**\n1. $N$\n2. $T$\n3. $P$\n4. $S$\n**[Descripción]**\na) Conjunto de reglas de derivación\nb) Símbolo inicial\nc) Conjunto de símbolos no terminales\nd) Conjunto de símbolos terminales",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1d, 2c, 3b, 4a",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "Definición estándar de gramática: $N$ son no terminales, $T$ terminales, $P$ producciones (reglas), $S$ símbolo inicial (Start)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione la operación de expresiones regulares con su símbolo estándar.\n**[Operación]**\n1. Unión\n2. Concatenación\n3. Cerradura de Kleene\n**[Símbolo]**\na) *\nb) |\nc) (Yuxtaposición o punto)",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: La barra vertical `|` denota unión (o). 2-c: La yuxtaposición `ab` denota concatenación. 3-a: El asterisco `*` denota cerradura de Kleene (0 o más veces)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione la característica de la gramática con el tipo de analizador sintáctico adecuado.\n**[Característica Gramatical]**\n1. Gramática con recursividad por la izquierda\n2. Gramática sin recursividad izquierda y factorizada\n3. Gramática LR(1)\n**[Analizador Adecuado]**\na) Analizador Ascendente (ej. YACC/Bison)\nb) No apta para Analizador Descendente Recursivo directo\nc) Analizador Descendente Predictivo (LL)",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1c, 2a, 3b",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: La recursividad izquierda causa bucles infinitos en parsers descendentes directos. 2-c: Las gramáticas LL (factorizadas, sin recursividad izq.) son ideales para parsers predictivos. 3-a: Los parsers ascendentes (como los generados por YACC) manejan gramáticas LR, que son más generales."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione el concepto de optimización con su descripción.\n**[Técnica]**\n1. Plegado de constantes (Constant Folding)\n2. Eliminación de código muerto\n3. Reducción de potencia (Strength Reduction)\n**[Descripción]**\na) Sustituir operaciones costosas por otras más baratas (ej. multiplicar por 2 $\\to$ desplazamiento de bits).\nb) Evaluar expresiones con operandos constantes en tiempo de compilación.\nc) Remover instrucciones que no afectan el resultado final del programa.",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Calcular `2+3` como `5` durante la compilación (Plegado de constantes). 2-c: Borrar código inalcanzable o sin efectos (Eliminación de código muerto). 3-a: Usar operaciones de bajo costo (shift) en lugar de alto costo (mul/div) (Reducción de potencia)."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione la estructura de datos del compilador con la información específica que gestiona para el manejo de ámbitos (scoping).\n**[Estructura]**\n1. Pila de tablas de símbolos\n2. Registro de activación (AR)\n3. Árbol de activación\n**[Función]**\na) Gestiona la memoria local y parámetros de una llamada a función en tiempo de ejecución.\nb) Representa el flujo de control de las llamadas a funciones.\nc) Maneja la visibilidad de identificadores en bloques anidados durante el análisis semántico.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1b, 2c, 3a",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Se usa una pila de tablas para entrar y salir de ámbitos (bloques) y resolver la visibilidad léxica. 2-a: El AR contiene datos vivos de una función en ejecución. 3-b: Modela la jerarquía de llamadas activas."
  },
  {
    "tema": "Desarrollo de Software de Base - Compiladores",
    "pregunta": "Relacione el problema de compilación con la solución teórica o técnica aplicada para resolverlo, integrando conceptos de autómatas y gramáticas.\n**[Problema]**\n1. Reconocimiento de palabras clave vs. identificadores\n2. Manejo de la precedencia de operadores en expresiones (ej. $*$ sobre $+$)\n3. Decidir si un programa se detendrá (Halting Problem)\n**[Solución/Concepto]**\na) Indecidible (no existe algoritmo para TM).\nb) Diseño de gramática estratificada o no ambigua.\nc) Orden de prioridad en reglas léxicas o autómata finito único.",
    "opciones": {
      "A": "1c, 2b, 3a",
      "B": "1b, 2a, 3c",
      "C": "1a, 2c, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: En el análisis léxico, se usa una regla de prioridad si un lexema coincide con una palabra clave y un identificador. 2-b: En el análisis sintáctico, la precedencia se resuelve creando niveles en la gramática. 3-a: Es un problema de la Teoría de Computación que ha demostrado ser indecidible en Máquinas de Turing."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "En el modelo TCP/IP, ¿cuál es la capa responsable de proporcionar comunicación lógica extremo a extremo entre procesos de aplicación y que puede ofrecer servicios de fiabilidad y control de flujo?",
    "opciones": {
      "A": "Capa de Red",
      "B": "Capa de Transporte",
      "C": "Capa de Enlace"
    },
    "respuesta_correcta": "B",
    "justificacion": "La capa de Transporte (donde residen TCP y UDP) es la encargada de la comunicación host-to-host a nivel de procesos, manejando la fiabilidad y el control de flujo."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "¿Cuál es el protocolo de la capa de aplicación utilizado para la resolución de nombres de dominio a direcciones IP?",
    "opciones": {
      "A": "DHCP",
      "B": "HTTP",
      "C": "DNS"
    },
    "respuesta_correcta": "C",
    "justificacion": "DNS (Domain Name System) es el protocolo encargado de traducir nombres de dominio legibles por humanos a direcciones IP numéricas."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "¿Qué dispositivo de red opera principalmente en la Capa 2 (Enlace de Datos) del modelo OSI y utiliza direcciones MAC para filtrar y reenviar tramas?",
    "opciones": {
      "A": "Hub",
      "B": "Router",
      "C": "Switch"
    },
    "respuesta_correcta": "C",
    "justificacion": "El Switch es un dispositivo de Capa 2 que toma decisiones de reenvío basándose en direcciones físicas (MAC)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "¿Qué protocolo de la capa de transporte sería más adecuado para una aplicación de transmisión de video en tiempo real donde la velocidad es crítica y se tolera cierta pérdida de datos?",
    "opciones": {
      "A": "TCP",
      "B": "UDP",
      "C": "FTP"
    },
    "respuesta_correcta": "B",
    "justificacion": "UDP no tiene el overhead de establecimiento de conexión ni retransmisión de TCP, lo que lo hace ideal para aplicaciones sensibles al tiempo como el streaming o VoIP, donde es preferible perder un paquete que detener la transmisión."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "En el contexto de la seguridad de red, ¿qué característica distingue principalmente a IPsec de SSL/TLS?",
    "opciones": {
      "A": "IPsec opera en la capa de red cifrando todo el datagrama IP, mientras que SSL/TLS opera sobre la capa de transporte.",
      "B": "SSL/TLS solo cifra la cabecera del paquete, mientras que IPsec cifra solo la carga útil.",
      "C": "IPsec se utiliza exclusivamente para asegurar correos electrónicos, mientras que SSL/TLS asegura la web."
    },
    "respuesta_correcta": "A",
    "justificacion": "IPsec es un protocolo de Capa 3 que asegura paquetes IP completos (VPNs), mientras que SSL/TLS opera en Capa 4/5 asegurando flujos de datos de aplicaciones específicas (HTTPS)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "¿Qué diferencia fundamental existe entre los protocolos de enrutamiento OSPF y BGP?",
    "opciones": {
      "A": "OSPF es un protocolo de vector de distancias, mientras que BGP es de estado de enlace.",
      "B": "OSPF se utiliza para enrutamiento dentro de un sistema autónomo (Intra-AS), mientras que BGP se utiliza entre sistemas autónomos (Inter-AS).",
      "C": "BGP garantiza la entrega más rápida posible, mientras que OSPF se centra en políticas de seguridad."
    },
    "respuesta_correcta": "B",
    "justificacion": "OSPF es un IGP (Interior Gateway Protocol) usado dentro de organizaciones (Intra-dominio). BGP es un EGP (Exterior Gateway Protocol) diseñado para conectar diferentes sistemas autónomos en Internet (Inter-dominio)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Para garantizar Calidad de Servicio (QoS) en una red convergente, ¿qué mecanismo se utiliza para clasificar y marcar paquetes a fin de darles tratamiento preferencial en los routers?",
    "opciones": {
      "A": "Control de congestión de TCP (Windowing).",
      "B": "Servicios Diferenciados (DiffServ).",
      "C": "Traducción de Direcciones de Red (NAT)."
    },
    "respuesta_correcta": "B",
    "justificacion": "DiffServ es una arquitectura de QoS que marca paquetes para que los routers intermedios apliquen políticas de prioridad sin mantener estado por flujo."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "En una arquitectura definida por software (SDN), ¿cuál es el cambio fundamental respecto a las redes tradicionales?",
    "opciones": {
      "A": "La eliminación física de los cables de red.",
      "B": "La separación del plano de control del plano de datos, centralizando la lógica de control.",
      "C": "El uso exclusivo de IPv6 sobre IPv4."
    },
    "respuesta_correcta": "B",
    "justificacion": "SDN desacopla el plano de control (lógica global de enrutamiento) del plano de datos (reenvío local en el router), permitiendo programabilidad y gestión dinámica."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "El protocolo **_______** es el estándar para la transferencia de archivos en Internet, permitiendo subir y bajar archivos de un servidor, mientras que **_______** es el protocolo utilizado para la asignación dinámica de direcciones IP a los dispositivos de una red.",
    "opciones": {
      "A": "DNS, SMTP",
      "B": "HTTP, ARP",
      "C": "FTP, DHCP"
    },
    "respuesta_correcta": "C",
    "justificacion": "FTP (File Transfer Protocol) es para transferencia de archivos. DHCP (Dynamic Host Configuration Protocol) automatiza la configuración de red de los hosts."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "En el modelo OSI, la capa de **_______** se encarga del direccionamiento físico y el acceso al medio, utilizando la dirección **_______** como identificador único de hardware.",
    "opciones": {
      "A": "Red, IP",
      "B": "Enlace de Datos, MAC",
      "C": "Transporte, Puerto"
    },
    "respuesta_correcta": "B",
    "justificacion": "La Capa 2 (Enlace) maneja el acceso al medio (como Ethernet) y usa direcciones MAC (Media Access Control) físicas grabadas en la tarjeta de red."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "El mecanismo de **_______** permite que múltiples dispositivos en una red privada compartan una única dirección IP pública para acceder a Internet.",
    "opciones": {
      "A": "DNS (Domain Name System)",
      "B": "NAT (Network Address Translation)",
      "C": "ARP (Address Resolution Protocol)"
    },
    "respuesta_correcta": "B",
    "justificacion": "NAT traduce direcciones IP privadas a una pública (y viceversa), permitiendo la conservación de direcciones IPv4 y cierto grado de seguridad."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Para verificar la conectividad básica entre dos hosts y medir el tiempo de ida y vuelta, se utiliza la herramienta **_______**, que emplea el protocolo **_______**.",
    "opciones": {
      "A": "Telnet, TCP",
      "B": "Traceroute, UDP",
      "C": "Ping, ICMP"
    },
    "respuesta_correcta": "C",
    "justificacion": "Ping es la herramienta de diagnóstico básica que envía mensajes de eco ICMP (Internet Control Message Protocol) para verificar si un destino es alcanzable."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "El establecimiento de una conexión TCP utiliza un proceso conocido como **_______**, que involucra el intercambio de segmentos con los flags SYN, **_______** y ACK.",
    "opciones": {
      "A": "Ventana deslizante, FIN",
      "B": "Saludo de tres vías (Three-way handshake), SYN-ACK",
      "C": "Encapsulamiento, PSH"
    },
    "respuesta_correcta": "B",
    "justificacion": "El \"Three-way handshake\" es el proceso fundamental de TCP: Cliente envía SYN, Servidor responde SYN-ACK, Cliente confirma ACK."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "En el protocolo IPsec, el modo **_______** cifra solo la carga útil del paquete IP (dejando la cabecera original intacta), mientras que el modo **_______** cifra todo el paquete original y lo encapsula en uno nuevo, siendo este último el más común para VPNs.",
    "opciones": {
      "A": "Transporte, Túnel",
      "B": "Túnel, Transporte",
      "C": "Autenticación, Cifrado"
    },
    "respuesta_correcta": "A",
    "justificacion": "El modo Transporte se usa para comunicaciones host-a-host (solo datos cifrados). El modo Túnel cifra todo el paquete IP original (datos + cabecera) y es el estándar para VPNs seguras entre redes."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Para mitigar el agotamiento de direcciones IPv4, se desarrolló **_______**, que utiliza direcciones de **_______** bits, ofreciendo un espacio de direccionamiento inmensamente mayor.",
    "opciones": {
      "A": "NAT, 64",
      "B": "IPv6, 128",
      "C": "IPv5, 256"
    },
    "respuesta_correcta": "B",
    "justificacion": "IPv6 es el sucesor de IPv4. IPv4 usa 32 bits, mientras que IPv6 usa 128 bits."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "El protocolo **_______** es utilizado por los navegadores web para establecer una comunicación segura; este protocolo opera insertando una capa de seguridad entre la capa de **_______** y la de transporte.",
    "opciones": {
      "A": "SSH, Red",
      "B": "HTTPS (SSL/TLS), Aplicación",
      "C": "IPsec, Enlace"
    },
    "respuesta_correcta": "B",
    "justificacion": "HTTPS no es un protocolo nuevo, es HTTP sobre SSL/TLS. SSL/TLS se sitúa entre la Capa de Aplicación y la de Transporte (TCP)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione la capa del modelo TCP/IP con su Unidad de Datos de Protocolo (PDU) correspondiente.\n**[Capa]**\n1. Aplicación\n2. Transporte\n3. Red (Internet)\n4. Enlace (Acceso a Red)\n**[PDU]**\na) Datagrama / Paquete\nb) Mensaje / Datos\nc) Trama (Frame)\nd) Segmento (TCP) / Datagrama (UDP)",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1a, 2c, 3d, 4b",
      "C": "1d, 2a, 3b, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Aplicación usa mensajes o datos. 2-d: Transporte usa Segmentos/Datagramas. 3-a: Red usa Datagramas/Paquetes. 4-c: Enlace usa Tramas."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el protocolo de aplicación con su número de puerto estándar.\n**[Protocolo]**\n1. HTTP\n2. HTTPS\n3. DNS\n4. SMTP\n**[Puerto]**\na) 53\nb) 443\nc) 25\nd) 80",
    "opciones": {
      "A": "1d, 2a, 3b, 4c",
      "B": "1d, 2b, 3a, 4c",
      "C": "1b, 2d, 3c, 4a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-d: HTTP (80). 2-b: HTTPS (443). 3-a: DNS (53). 4-c: SMTP (25)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el dispositivo de red con la capa del modelo OSI en la que opera principalmente.\n**[Dispositivo]**\n1. Router\n2. Switch\n3. Hub\n4. Firewall (Filtrado de paquetes)\n**[Capa OSI]**\na) Capa 1 (Física)\nb) Capa 2 (Enlace de Datos)\nc) Capa 3 (Red) y superior\nd) Capa 3 (Red)",
    "opciones": {
      "A": "1c, 2b, 3a, 4d",
      "B": "1d, 2b, 3a, 4c",
      "C": "1b, 2d, 3c, 4a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-d: Router (Capa 3). 2-b: Switch (Capa 2). 3-a: Hub (Capa 1). 4-c: Firewall (Capa 3 y superior)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el medio de transmisión con su característica principal.\n**[Medio]**\n1. Fibra Óptica\n2. Cable UTP (Par Trenzado)\n3. Cable Coaxial\n4. WiFi (Aire)\n**[Característica]**\na) Transmisión por ondas de radio, susceptible a interferencias.\nb) Núcleo de vidrio, transmisión por luz, inmune a interferencia electromagnética, alta velocidad y distancia.\nc) Hilos de cobre trenzados para cancelar interferencia, común en LANs, distancia limitada (100m).\nd) Conductor central de cobre, blindado, usado en TV por cable y redes antiguas.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1a, 2b, 3c, 4d",
      "C": "1c, 2d, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Fibra (luz, inmune a EMI). 2-c: UTP (trenzados, 100m). 3-d: Coaxial (blindado, redes antiguas). 4-a: WiFi (ondas de radio, susceptible a interferencias)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el comando de red con su utilidad principal.\n**[Comando]**\n1. ipconfig / ifconfig\n2. ping\n3. tracert / traceroute\n4. nslookup\n**[Utilidad]**\na) Consultar servidores DNS para obtener información de dominios.\nb) Mostrar la configuración IP actual del adaptador de red.\nc) Verificar conectividad básica con un host remoto.\nd) Mostrar la ruta y saltos que toman los paquetes hacia un destino.",
    "opciones": {
      "A": "1b, 2d, 3c, 4a",
      "B": "1b, 2c, 3d, 4a",
      "C": "1a, 2b, 3c, 4d"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: ipconfig/ifconfig (configuración local). 2-c: ping (conectividad). 3-d: tracert (traza de ruta). 4-a: nslookup (consultas DNS)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el tipo de ataque a la seguridad de red con su descripción técnica.\n**[Ataque]**\n1. DDoS (Distributed Denial of Service)\n2. Man-in-the-Middle (MitM)\n3. IP Spoofing\n4. Sniffing\n**[Descripción]**\na) Interceptar y leer tráfico de red en tránsito sin autorización.\nb) Saturar un servidor o red con tráfico desde múltiples fuentes para dejarlo inoperable.\nc) Interceptar y posiblemente alterar la comunicación entre dos partes que creen comunicarse directamente.\nd) Falsificar la dirección IP de origen en los paquetes para ocultar la identidad o suplantar a otro sistema confiable.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1a, 2b, 3c, 4d",
      "C": "1c, 2d, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: DDoS (Saturar con tráfico). 2-c: MitM (Intervenir la comunicación). 3-d: IP Spoofing (Falsificar la IP de origen). 4-a: Sniffing (Escucha pasiva)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el protocolo de la suite IPsec con su función específica.\n**[Protocolo/Concepto]**\n1. AH (Authentication Header)\n2. ESP (Encapsulating Security Payload)\n3. IKE (Internet Key Exchange)\n4. SA (Security Association)\n**[Función]**\na) Proporciona autenticación e integridad, pero NO confidencialidad (cifrado).\nb) Acuerdo unidireccional lógico entre dos partes que define parámetros de seguridad (claves, algoritmos).\nc) Proporciona confidencialidad (cifrado), autenticación e integridad.\nd) Protocolo para negociar y establecer claves de sesión y asociaciones de seguridad.",
    "opciones": {
      "A": "1a, 2c, 3d, 4b",
      "B": "1c, 2a, 3b, 4d",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: AH (Autenticación sin cifrado). 2-c: ESP (Cifrado, autenticación e integridad). 3-d: IKE (Negociación de claves). 4-b: SA (Acuerdo de seguridad)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione la métrica de Calidad de Servicio (QoS) con su impacto en aplicaciones de Voz sobre IP (VoIP).\n**[Métrica]**\n1. Ancho de banda (Bandwidth)\n2. Latencia (Delay)\n3. Jitter (Variación del retardo)\n4. Pérdida de paquetes (Packet Loss)\n**[Impacto en VoIP]**\na) Si es alto, la voz suena robotizada o se entrecorta; requiere un buffer de reproducción (jitter buffer) para compensar.\nb) Si es insuficiente, no se puede establecer la llamada o se degrada la calidad del códec.\nc) Si es alto (>150ms), la conversación se vuelve difícil por los \"pisos\" al hablar (efecto walkie-talkie).\nd) Provoca huecos de silencio o clicks en la conversación; VoIP tolera muy poco (<1%).",
    "opciones": {
      "A": "1b, 2c, 3a, 4d",
      "B": "1a, 2b, 3c, 4d",
      "C": "1d, 2a, 3b, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Ancho de banda (capacidad de caudal). 2-c: Latencia (afecta interactividad). 3-a: Jitter (variación de llegada, requiere buffer). 4-d: Pérdida (huecos/clicks)."
  },
  {
    "tema": "Desarrollo de Software de Base - Redes de Computadoras",
    "pregunta": "Relacione el escenario de problema de red con la capa del modelo OSI donde reside la causa raíz y la solución teórica.\n**[Escenario]**\n1. Los usuarios no pueden acceder a `www.google.com` pero sí pueden hacer ping a `8.8.8.8`.\n2. Un servidor web recibe las peticiones TCP SYN pero nunca responde con SYN-ACK, saturándose (ataque SYN Flood).\n3. Un cable de red pasa cerca de un motor eléctrico potente y la conexión es intermitente.\n4. Dos computadoras tienen configurada la misma dirección IP estática en la misma LAN.\n**[Capa y Solución]**\na) Capa Física: Problema de interferencia electromagnética. Solución: Usar fibra óptica o cable blindado (STP).\nb) Capa de Red (Lógica): Conflicto de direccionamiento. Solución: Configurar DHCP o corregir la IP estática.\nc) Capa de Aplicación: Fallo de resolución de nombres. Solución: Verificar configuración de servidor DNS.\nd) Capa de Transporte: Agotamiento de recursos. Solución: Implementar SYN Cookies o Firewall con protección de estado.",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1b, 2a, 3d, 4c",
      "C": "1d, 2b, 3c, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Conectividad IP sí funciona, el problema es DNS (Capa Aplicación). 2-d: SYN Flood explota TCP (Capa Transporte). 3-a: Interferencia física (Capa Física). 4-b: Conflicto de IP (Capa Red)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "¿Cuál es el modelo de proceso de software que sugiere un enfoque sistemático y secuencial para el desarrollo del software, que comienza con la especificación de requerimientos y avanza a través de planeación, modelado, construcción y despliegue, concluyendo con el soporte del software terminado?",
    "opciones": {
      "A": "Modelo en Espiral",
      "B": "Modelo en Cascada",
      "C": "Desarrollo Ágil"
    },
    "respuesta_correcta": "B",
    "justificacion": "El modelo en cascada (Waterfall) es el enfoque clásico que plantea un desarrollo lineal y secuencial, donde cada fase debe completarse antes de iniciar la siguiente."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "En el contexto de la ingeniería de requerimientos, ¿cómo se clasifica un requerimiento que especifica que \"el sistema debe ser capaz de procesar 100 transacciones por segundo\"?",
    "opciones": {
      "A": "Requerimiento funcional",
      "B": "Requerimiento de dominio",
      "C": "Requerimiento no funcional"
    },
    "respuesta_correcta": "C",
    "justificacion": "Los requerimientos no funcionales son restricciones de los servicios o funciones, como restricciones de tiempo, proceso de desarrollo o estándares. La velocidad de procesamiento es una restricción de rendimiento (calidad), no una función específica del negocio."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "¿Qué propiedad de las transacciones en una base de datos garantiza que, una vez que una transacción se ha confirmado, sus efectos son permanentes incluso si hay un fallo del sistema inmediatamente después?",
    "opciones": {
      "A": "Atomicidad",
      "B": "Aislamiento",
      "C": "Durabilidad"
    },
    "respuesta_correcta": "C",
    "justificacion": "La durabilidad (parte de las propiedades ACID) asegura que los cambios de una transacción comprometida persisten."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "¿Cuál es el término utilizado en la gestión de configuración para denotar una versión específica de un elemento de configuración que ha sido revisada y acordada formalmente, y que sirve como base para un desarrollo posterior?",
    "opciones": {
      "A": "Línea base (Baseline)",
      "B": "Rama (Branch)",
      "C": "Repositorio"
    },
    "respuesta_correcta": "A",
    "justificacion": "Una línea base es una especificación o producto que ha sido revisado y acordado formalmente, sirviendo de base para el desarrollo futuro y cambiable solo a través de procedimientos formales."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Una empresa financiera necesita desarrollar un sistema crítico donde la seguridad y la minimización de riesgos son la máxima prioridad. Los requerimientos no están completamente claros al inicio. ¿Qué modelo de proceso es el más adecuado?",
    "opciones": {
      "A": "Modelo en Cascada",
      "B": "Modelo en Espiral",
      "C": "Desarrollo Basado en Componentes"
    },
    "respuesta_correcta": "B",
    "justificacion": "El modelo en espiral de Boehm es un marco de proceso dirigido explícitamente por el riesgo, incluyendo una fase de análisis de riesgos en cada ciclo, ideal para sistemas críticos con incertidumbre."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "En una base de datos distribuida, se desea asegurar que si una localidad falla, los datos sigan disponibles en otra localidad. ¿Qué técnica de distribución de datos se debe implementar?",
    "opciones": {
      "A": "Fragmentación horizontal",
      "B": "Replicación",
      "C": "Normalización"
    },
    "respuesta_correcta": "B",
    "justificacion": "La replicación consiste en almacenar copias de la misma información en múltiples nodos. Esto aumenta la disponibilidad (tolerancia a fallos) y el rendimiento de lectura."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Usted está diseñando un Data Warehouse. Se decide utilizar un esquema que consta de una tabla central grande que contiene los datos métricos del negocio y varias tablas pequeñas auxiliares que contienen los atributos descriptivos. ¿A qué tipo de esquema se refiere?",
    "opciones": {
      "A": "Esquema de Copo de Nieve",
      "B": "Esquema de Estrella",
      "C": "Esquema Relacional Normalizado"
    },
    "respuesta_correcta": "B",
    "justificacion": "El esquema de estrella tiene una tabla de hechos central rodeada por tablas de dimensiones. Es el diseño más simple y común para Data Warehouses, optimizado para consultas analíticas (OLAP)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Al realizar una estimación de costos con el modelo COCOMO II, ¿cuál es el factor principal que determina el esfuerzo inicial antes de ajustar por los conductores de costo?",
    "opciones": {
      "A": "El tamaño del código (líneas de código o puntos de función)",
      "B": "La experiencia del equipo",
      "C": "La complejidad del hardware"
    },
    "respuesta_correcta": "A",
    "justificacion": "Los modelos algorítmicos de costos como COCOMO se basan fundamentalmente en el tamaño del software (KLOC o Puntos de Función)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "El ciclo de vida clásico del software, también conocido como modelo en cascada, consta de las siguientes fases secuenciales: Definición de requerimientos, **_______**, Implementación y prueba de unidades, Integración y prueba del sistema, y Funcionamiento y mantenimiento.",
    "opciones": {
      "A": "Análisis de riesgos",
      "B": "Diseño del sistema y del software",
      "C": "Prototipado rápido"
    },
    "respuesta_correcta": "B",
    "justificacion": "Según el modelo en cascada, después de definir requerimientos sigue el diseño del sistema y software antes de codificar."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "En el contexto de pruebas de software, la prueba de **_______** verifica que el sistema cumple con los requerimientos funcionales y no funcionales especificados por el usuario, validando el producto final.",
    "opciones": {
      "A": "integración",
      "B": "unidad",
      "C": "aceptación"
    },
    "respuesta_correcta": "C",
    "justificacion": "La prueba de aceptación es la etapa final antes de liberar el sistema, donde se prueba con datos del cliente para verificar que cumple sus necesidades reales."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Una **_______** es una colección de datos orientada a temas, integrada, no volátil y variable en el tiempo, organizada para soportar necesidades de toma de decisiones de la gerencia.",
    "opciones": {
      "A": "Base de Datos Distribuida",
      "B": "Data Warehouse",
      "C": "Minería de Datos"
    },
    "respuesta_correcta": "B",
    "justificacion": "Esta es la definición canónica de un Data Warehouse (Almacén de Datos), diseñado para OLAP y análisis histórico, a diferencia de las bases de datos operacionales (OLTP)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "El lenguaje **_______** es un estándar para el modelado visual de sistemas de software que se utiliza para especificar, visualizar, construir y documentar los artefactos de un sistema de software.",
    "opciones": {
      "A": "SQL",
      "B": "UML",
      "C": "XML"
    },
    "respuesta_correcta": "B",
    "justificacion": "UML (Unified Modeling Language) es el estándar de facto para el modelado orientado a objetos, incluyendo diagramas de clases, secuencia, casos de uso, etc."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "En una base de datos distribuida, para reconstruir la relación global a partir de fragmentos obtenidos mediante **_______**, se debe utilizar la operación de unión.",
    "opciones": {
      "A": "fragmentación vertical",
      "B": "fragmentación horizontal",
      "C": "fragmentación híbrida"
    },
    "respuesta_correcta": "B",
    "justificacion": "La fragmentación horizontal divide la tabla en subconjuntos de tuplas (filas). Para recuperar la tabla original, se deben unir (Union) estas filas. La fragmentación vertical requiere la operación de Join (Junta)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Considere el siguiente fragmento de álgebra relacional para una fragmentación:\n$R1 = \\sigma_{Dno=5}(EMPLEADO)$\n$R2 = \\sigma_{Dno \\neq 5}(EMPLEADO)$\nEsta operación representa una **_______** que cumple con la regla de **_______**.",
    "opciones": {
      "A": "fragmentación vertical - preservación de dependencias",
      "B": "fragmentación horizontal - completitud",
      "C": "replicación total - minimización"
    },
    "respuesta_correcta": "B",
    "justificacion": "El operador sigma ($\\sigma$) denota selección de filas (fragmentación horizontal). La regla de completitud exige que todos los datos de la relación original se encuentren en algún fragmento, lo cual se asegura usando una condición y su negación."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "El **_______** es un patrón de diseño arquitectónico que estructura el sistema en tres componentes lógicos: la interfaz de usuario, la lógica de control y el modelo de datos, facilitando la mantenibilidad y la evolución independiente de las interfaces.",
    "opciones": {
      "A": "Cliente-Servidor",
      "B": "Modelo-Vista-Controlador (MVC)",
      "C": "Arquitectura en Capas"
    },
    "respuesta_correcta": "B",
    "justificacion": "El patrón MVC (Model-View-Controller) separa explícitamente la presentación (Vista), la lógica de interacción (Controlador) y los datos (Modelo)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "En la gestión de riesgos, si se identifica un riesgo de \"alta probabilidad\" y \"alto impacto\" relacionado con la inestabilidad de una tecnología clave, la estrategia de **_______** sugiere desarrollar un prototipo desechable para evaluar la tecnología antes de comprometerse con el desarrollo completo.",
    "opciones": {
      "A": "transferencia",
      "B": "mitigación (o reducción)",
      "C": "aceptación"
    },
    "respuesta_correcta": "B",
    "justificacion": "La mitigación o reducción de riesgos busca disminuir la probabilidad o el impacto. El uso de prototipos para investigar tecnología reduce la incertidumbre (probabilidad de fallo técnico)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione el tipo de mantenimiento de software con su descripción.\n**Tipos**\n1. Correctivo\n2. Adaptativo\n3. Perfectivo\n4. Preventivo\n**Descripción**\na) Modificación para corregir defectos descubiertos.\nb) Modificación para mejorar el rendimiento o la mantenibilidad sin cambiar la funcionalidad.\nc) Modificación para mantener el software utilizable en un entorno cambiante.\nd) Modificación para detectar y corregir fallos latentes antes de que sean efectivos.",
    "opciones": {
      "A": "1a, 2c, 3b, 4d",
      "B": "1a, 2b, 3c, 4d",
      "C": "1c, 2a, 3d, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "Correctivo arregla errores (1a). Adaptativo ajusta al entorno (2c). Perfectivo mejora cualidades o agrega funciones pedidas por usuario (3b). Preventivo anticipa problemas (4d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione las fases del RUP (Rational Unified Process) con su objetivo principal.\n**Fases**\n1. Inicio\n2. Elaboración\n3. Construcción\n4. Transición\n**Objetivo**\na) Desarrollar el sistema operativo y la documentación.\nb) Establecer el caso de negocio y el alcance del proyecto.\nc) Desplegar el sistema en el entorno del usuario.\nd) Analizar el dominio, establecer la arquitectura base y mitigar riesgos principales.",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1b, 2d, 3a, 4c",
      "C": "1d, 2b, 3a, 4c"
    },
    "respuesta_correcta": "B",
    "justificacion": "Inicio define el alcance (1b). Elaboración define la arquitectura y riesgos (2d). Construcción desarrolla el producto (3a). Transición entrega al usuario (4c)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione el tipo de prueba con su descripción.\n**Tipo de Prueba**\n1. Prueba de unidad\n2. Prueba de integración\n3. Prueba de sistema\n4. Prueba de regresión\n**Descripción**\na) Verifica que los cambios recientes no hayan alterado funciones existentes.\nb) Verifica el funcionamiento de componentes individuales (clases, funciones).\nc) Verifica la interacción entre componentes ensamblados.\nd) Verifica el comportamiento del sistema completo contra los requerimientos.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1c, 2b, 3a, 4d",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "Unidad prueba componentes aislados (1b). Integración prueba interfaces entre componentes (2c). Sistema prueba el todo (3d). Regresión asegura que lo que funcionaba siga funcionando (4a)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione los conceptos de bases de datos con su definición.\n**Concepto**\n1. DDL (Data Definition Language)\n2. DML (Data Manipulation Language)\n3. SGBD (Sistema Gestor de BD)\n4. Clave Primaria\n**Definición**\na) Software que permite definir, crear y mantener la base de datos.\nb) Identificador único para cada registro en una tabla.\nc) Comandos para definir esquemas (CREATE, ALTER).\nd) Comandos para gestionar datos (SELECT, INSERT).",
    "opciones": {
      "A": "1d, 2c, 3a, 4b",
      "B": "1c, 2d, 3a, 4b",
      "C": "1c, 2d, 3b, 4a"
    },
    "respuesta_correcta": "B",
    "justificacion": "DDL define estructura (1c). DML manipula datos (2d). SGBD es el software de gestión (3a). Clave Primaria identifica registros (4b)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione las métricas de calidad de software con su categoría.\n**Métrica**\n1. Tiempo medio entre fallos (MTBF)\n2. Tiempo de aprendizaje\n3. Memoria utilizada\n4. Tiempo de reinicio tras fallo\n**Categoría**\na) Usabilidad\nb) Fiabilidad\nc) Eficiencia\nd) Robustez",
    "opciones": {
      "A": "1b, 2a, 3c, 4d",
      "B": "1d, 2a, 3b, 4c",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "MTBF mide fiabilidad (1b). Aprendizaje es usabilidad (2a). Memoria es eficiencia de recursos (3c). Reinicio es robustez/recuperabilidad (4d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione las estrategias de gestión de riesgos con las acciones específicas para un proyecto de software.\n**Estrategia**\n1. Evitación de riesgos\n2. Minimización de riesgos\n3. Planes de contingencia\n**Acción**\na) Comprar componentes de software probados en lugar de construirlos desde cero para evitar fallos de diseño.\nb) Preparar un fondo de emergencia y un equipo de \"bomberos\" por si el servidor falla.\nc) Usar programación defensiva y validación exhaustiva para reducir el impacto de posibles errores de datos.",
    "opciones": {
      "A": "1a, 2c, 3b",
      "B": "1b, 2a, 3c",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "Evitar el riesgo significa no realizar la actividad riesgosa (1a). Minimizar reduce el impacto o probabilidad (programación defensiva) (2c). Contingencia es qué hacer si el riesgo ocurre (fondo de emergencia) (3b)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione el nivel de transparencia en bases de datos distribuidas con su descripción técnica.\n**Nivel de Transparencia**\n1. Transparencia de Localización\n2. Transparencia de Fragmentación\n3. Transparencia de Replicación\n**Descripción**\na) El usuario no necesita saber que los datos están divididos en pedazos; consulta la relación global.\nb) El usuario no necesita saber en qué nodo de la red residen los datos; usa nombres lógicos.\nc) El usuario no necesita saber que existen copias de los datos; el sistema gestiona la consistencia.",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "Localización: el usuario ignora la ubicación física (1b). Fragmentación: el usuario ignora la partición de tablas (2a). Replicación: el usuario ignora la existencia de copias (3c)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Relacione la técnica de diseño de pruebas (caja negra/blanca) con el método específico.\n**Técnica**\n1. Caja Negra\n2. Caja Blanca\n**Método**\na) Partición de equivalencia\nb) Cobertura de caminos (Path testing)\nc) Análisis de valores límite\nd) Prueba de flujo de datos",
    "opciones": {
      "A": "1a, 1c - 2b, 2d",
      "B": "1b, 1d - 2a, 2c",
      "C": "1a, 1d - 2b, 2c"
    },
    "respuesta_correcta": "A",
    "justificacion": "Caja Negra se basa en la especificación: partición de equivalencia (1a) y valores límite (1c). Caja Blanca se basa en la estructura interna: cobertura de caminos (2b) y flujo de datos (2d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Ingeniería de Software",
    "pregunta": "Un banco internacional desea actualizar su sistema. Requieren alta disponibilidad global (24/7), consistencia estricta en transacciones financieras y capacidad de analizar tendencias históricas de todos sus clientes para ofrecer nuevos productos. Relacione los requerimientos con las soluciones arquitectónicas y metodológicas adecuadas.\n**Requerimiento**\n1. Consistencia estricta en transacciones distribuidas\n2. Análisis de tendencias históricas masivas\n3. Alta disponibilidad ante fallos de un servidor\n4. Metodología para requisitos cambiantes y entrega rápida\n**Solución**\na) Implementación de un Data Warehouse con esquema de estrella\nb) Protocolo de confirmación en dos fases (2PC)\nc) Desarrollo Ágil (ej. Scrum) o Evolutivo\nd) Replicación de datos con gestión de fallos",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1d, 2a, 3b, 4c",
      "C": "1b, 2c, 3d, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: El protocolo 2PC garantiza atomicidad y consistencia en transacciones distribuidas (ACID). 2-a: Los Data Warehouses son específicos para análisis histórico y tendencias (OLAP). 3-d: La replicación asegura la alta disponibilidad. 4-c: Metodologías ágiles/evolutivas son para requisitos cambiantes."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En el contexto del desarrollo web, ¿cuál es la función principal de un lenguaje de _scripting_ del lado del servidor como PHP?",
    "opciones": {
      "A": "Definir la estructura semántica y el contenido del documento web que visualiza el usuario.",
      "B": "Procesar la lógica de negocio, interactuar con la base de datos y generar contenido dinámico antes de enviarlo al cliente.",
      "C": "Proporcionar estilos visuales, animaciones y adaptabilidad a diferentes tamaños de pantalla en el navegador."
    },
    "respuesta_correcta": "B",
    "justificacion": "PHP es un lenguaje de _Back-End_ (lado del servidor). Su función es procesar datos, conectar con bases de datos (como MySQL) y generar el HTML resultante."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En el paradigma de Programación Orientada a Objetos, ¿cómo se denomina al mecanismo que permite agrupar datos y los métodos que operan sobre esos datos en una sola unidad, ocultando los detalles internos de implementación?",
    "opciones": {
      "A": "Herencia",
      "B": "Polimorfismo",
      "C": "Encapsulamiento"
    },
    "respuesta_correcta": "C",
    "justificacion": "El encapsulamiento es el principio de ocultar el estado interno y la funcionalidad de un objeto, exponiendo solo lo necesario (interfaz pública)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "¿Cuál de los siguientes paradigmas de programación se basa en el cambio de estado del programa a través de la ejecución secuencial de instrucciones y el uso de asignaciones destructivas?",
    "opciones": {
      "A": "Paradigma Imperativo",
      "B": "Paradigma Funcional",
      "C": "Paradigma Lógico"
    },
    "respuesta_correcta": "A",
    "justificacion": "El paradigma imperativo (y por extensión el procedural) se centra en describir \"cómo\" se realiza la tarea mediante secuencias de comandos que modifican el estado de la memoria."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En el lenguaje Java, ¿cuál es la firma correcta para declarar el método principal (_main_) que sirve como punto de entrada de la aplicación?",
    "opciones": {
      "A": "`public void main(String args)`",
      "B": "`public static void main(String[] args)`",
      "C": "`static public int main(String args[])`"
    },
    "respuesta_correcta": "B",
    "justificacion": "Según la guía de referencia técnica para Java en el contexto del examen, el método principal debe ser público, estático, no retornar valor (`void`) y recibir un arreglo de cadenas (`String[] args`)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Analice el siguiente fragmento de código en C. ¿Qué concepto de manejo de memoria está ilustrado y cuál es el riesgo potencial?\n```c\nstruct recurso { float medida; float *acceso; };\nstruct recurso informe;\ninforme.acceso = &datos;\n```",
    "opciones": {
      "A": "Paso por valor; riesgo de duplicación de datos innecesaria.",
      "B": "Asignación de punteros; riesgo de acceder a memoria no válida si el arreglo `datos` sale de ámbito.",
      "C": "Herencia de estructuras; riesgo de sobrescritura de métodos en tiempo de ejecución."
    },
    "respuesta_correcta": "B",
    "justificacion": "El código asigna la dirección de memoria de un elemento de un arreglo a un puntero dentro de una estructura, que es manipulación directa de memoria (punteros). El riesgo (dangling pointer) ocurre si `datos` deja de existir."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En una aplicación que requiere alta concurrencia sin efectos secundarios en los datos compartidos, ¿qué paradigma de programación es el más recomendado y por qué?",
    "opciones": {
      "A": "Orientado a Objetos, debido a su capacidad de encapsular el estado en objetos individuales.",
      "B": "Imperativo, debido a su control granular sobre el flujo de ejecución y la memoria.",
      "C": "Funcional, debido a la inmutabilidad de los datos y la ausencia de efectos secundarios."
    },
    "respuesta_correcta": "C",
    "justificacion": "La programación funcional evita el estado mutable. Al no haber cambios de estado, se eliminan las condiciones de carrera en entornos concurrentes, lo que la hace ideal para este escenario."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Se desea implementar un sistema que intercambie información entre una aplicación móvil Android y un servidor web. La arquitectura debe ser ligera y sin estado. ¿Qué tecnología es la más adecuada para la comunicación?",
    "opciones": {
      "A": "SOAP con XML",
      "B": "API REST con JSON",
      "C": "Conexión directa a base de datos MySQL"
    },
    "respuesta_correcta": "B",
    "justificacion": "Para comunicación moderna, ligera y sin estado entre móvil y web, las APIs REST (generalmente usando JSON) son el estándar para el intercambio de información entre diferentes plataformas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Considere una clase `Figura` con un método `dibujar()` y dos subclases `Circulo` y `Cuadrado` que implementan su propia versión de `dibujar()`. Si se tiene una lista de tipo `Figura` que contiene instancias mixtas y se llama a `dibujar()` en cada una, se ejecuta la versión correcta. ¿Qué pilar de la POO permite esto?",
    "opciones": {
      "A": "Polimorfismo por sobrecarga",
      "B": "Polimorfismo por inclusión (o dinámico)",
      "C": "Herencia simple"
    },
    "respuesta_correcta": "B",
    "justificacion": "Es polimorfismo dinámico (o por inclusión/sobrescritura). El método a ejecutar se decide en tiempo de ejecución según el tipo real del objeto."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En la estructura de control repetitiva `do-while`, la condición se evalúa **_______** del bloque de instrucciones, lo que garantiza que el bloque se ejecute al menos **_______** vez/veces.",
    "opciones": {
      "A": "al inicio - una",
      "B": "al final - una",
      "C": "al final - cero"
    },
    "respuesta_correcta": "B",
    "justificacion": "El `do-while` ejecuta primero el cuerpo y luego evalúa la condición, garantizando al menos una ejecución."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En el lenguaje C, para declarar una variable que almacenará un número real con punto decimal, se utiliza la palabra reservada **_______**; mientras que para un número entero se utiliza **_______**.",
    "opciones": {
      "A": "float - int",
      "B": "real - entero",
      "C": "double - long"
    },
    "respuesta_correcta": "A",
    "justificacion": "Las palabras reservadas estándar en C para estos tipos de datos son `float` (o `double`) e `int`."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Para que una clase en Java pueda utilizar los métodos de otra clase existente, se debe establecer una relación de **_______**, utilizando la palabra reservada `extends`.",
    "opciones": {
      "A": "composición",
      "B": "herencia",
      "C": "instanciación"
    },
    "respuesta_correcta": "B",
    "justificacion": "La herencia es el mecanismo que permite a una clase derivar de otra. En Java se implementa explícitamente con `extends`."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En el contexto de bases de datos y programación, un **_______** es un bloque de código SQL almacenado en la base de datos que se ejecuta automáticamente en respuesta a un evento específico en una tabla.",
    "opciones": {
      "A": "procedimiento almacenado",
      "B": "disparador (trigger)",
      "C": "índice"
    },
    "respuesta_correcta": "B",
    "justificacion": "La característica de ejecución _automática_ ante un evento (INSERT, UPDATE, DELETE) define al disparador o _trigger_."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Analice el siguiente código recursivo:\n```c\nint funcion(int n) {\n  if (n == 0) return 1;\n  else return n * funcion(n - 1);\n}\n```\nSi se llama a `funcion(4)`, el valor de retorno será **_______** y el número de llamadas totales a la función (incluyendo la original) será **_______**.",
    "opciones": {
      "A": "24 - 4",
      "B": "24 - 5",
      "C": "12 - 5"
    },
    "respuesta_correcta": "B",
    "justificacion": "La función calcula el factorial. 4! = 24. Las llamadas son: f(4), f(3), f(2), f(1), f(0). Total = 5 llamadas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En la programación móvil para Android, el ciclo de vida de una **_______** es fundamental. Métodos como `onCreate()`, `onStart()` y `onResume()` gestionan los estados de la pantalla visible al usuario.",
    "opciones": {
      "A": "Activity (Actividad)",
      "B": "Service (Servicio)",
      "C": "Intent (Intención)"
    },
    "respuesta_correcta": "A",
    "justificacion": "En Android, una `Activity` representa una pantalla única con una interfaz de usuario. Su gestión de ciclo de vida es el concepto central del desarrollo en esta plataforma."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Para optimizar una consulta en una aplicación que maneja grandes volúmenes de datos, se decide utilizar un **_______** en la columna de búsqueda frecuente, lo que cambia la complejidad de búsqueda de O(n) a O(log n) en promedio.",
    "opciones": {
      "A": "arreglo",
      "B": "índice (B-tree)",
      "C": "disparador"
    },
    "respuesta_correcta": "B",
    "justificacion": "La estructura de datos subyacente de un índice en base de datos (comúnmente árboles B o B+) permite búsquedas logarítmicas, mejorando drásticamente el rendimiento frente a un escaneo secuencial."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "En C++, si una clase base tiene un método virtual puro, la clase se convierte en una clase **_______**, lo que impide su **_______**.",
    "opciones": {
      "A": "abstracta - herencia",
      "B": "abstracta - instanciación",
      "C": "estática - compilación"
    },
    "respuesta_correcta": "B",
    "justificacion": "Un método virtual puro hace que la clase sea abstracta. Las clases abstractas no pueden ser instanciadas (no se pueden crear objetos directos de ellas), solo pueden ser heredadas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione el paradigma de programación con su característica principal.\n**[Conjunto A] Paradigma**\n1. Orientado a Objetos\n2. Funcional\n3. Procedural\n4. Lógico\n**[Conjunto B] Característica**\na) Se basa en reglas y hechos formales.\nb) Estructura el programa en términos de entidades que combinan estado y comportamiento.\nc) Evita el estado mutable y trata el cómputo como evaluación matemática.\nd) Divide el programa en variables, datos y subrutinas secuenciales.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1c, 2b, 3a, 4d",
      "C": "1b, 2a, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "OO=Objetos (1b), Funcional=Matemática/Inmutabilidad (2c), Procedural=Subrutinas/Secuencial (3d), Lógico=Hechos/Reglas (4a)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione la estructura de control con su descripción.\n**[Conjunto A] Estructura**\n1. `if-else`\n2. `switch`\n3. `while`\n4. `for`\n**[Conjunto B] Descripción**\na) Ejecuta un bloque de código un número determinado de veces.\nb) Selecciona entre múltiples caminos basándose en el valor de una variable (generalmente entera o char).\nc) Ejecuta un bloque mientras una condición sea verdadera (0 a n veces).\nd) Evalúa una condición booleana para decidir entre dos caminos.",
    "opciones": {
      "A": "1d, 2b, 3c, 4a",
      "B": "1b, 2d, 3a, 4c",
      "C": "1d, 2a, 3c, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "if-else es la selección binaria (1d), switch es la selección múltiple (2b), while es el ciclo condicional (3c), for es el ciclo determinado/conteo (4a)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione el operador lógico/relacional en C con su función.\n**[Conjunto A] Operador**\n1. `&&`\n2. `||`\n3. `!=`\n4. `==`\n**[Conjunto B] Función**\na) Comparación de igualdad.\nb) AND lógico.\nc) OR lógico.\nd) Comparación de desigualdad.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1c, 2b, 3a, 4d",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "En C y derivados, `&&` es AND (1b), `||` es OR (2c), `!=` es diferente de (3d), y `==` es igual a (4a)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione el tipo de dato en C con su uso típico.\n**[Conjunto A] Tipo de Dato**\n1. `char`\n2. `int`\n3. `float`\n4. `void`\n**[Conjunto B] Uso**\na) Números con decimales.\nb) Caracteres individuales o enteros pequeños.\nc) Números enteros.\nd) Indicar que una función no retorna valor.",
    "opciones": {
      "A": "1b, 2c, 3a, 4d",
      "B": "1c, 2a, 3b, 4d",
      "C": "1b, 2a, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "`char` almacena caracteres (1b), `int` enteros (2c), `float` reales (3a), `void` es el tipo nulo o vacío para retornos de función (4d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione la función de manejo de cadenas en C con su propósito.\n**[Conjunto A] Función**\n1. `strlen`\n2. `strcpy`\n3. `strcat`\n4. `strcmp`\n**[Conjunto B] Propósito**\na) Concatena (une) dos cadenas.\nb) Compara dos cadenas.\nc) Obtiene la longitud de una cadena.\nd) Copia el contenido de una cadena a otra.",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1c, 2a, 3d, 4b",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "`strlen` (length, 1c), `strcpy` (copy, 2d), `strcat` (concatenate, 3a), `strcmp` (compare, 4b)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione el concepto de POO con el problema que resuelve en el diseño de software.\n**[Conjunto A] Concepto**\n1. Polimorfismo\n2. Herencia\n3. Encapsulamiento\n4. Abstracción\n**[Conjunto B] Problema Resuelto**\na) Reduce la duplicación de código al permitir compartir atributos y métodos comunes.\nb) Permite tratar objetos de tipos derivados como si fueran del tipo base, facilitando la extensibilidad.\nc) Protege la integridad de los datos internos impidiendo el acceso directo no autorizado.\nd) Simplifica la complejidad enfocándose en las características esenciales y ocultando detalles irrelevantes.",
    "opciones": {
      "A": "1b, 2a, 3c, 4d",
      "B": "1a, 2b, 3d, 4c",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "Polimorfismo = extensibilidad/trato uniforme (1b); Herencia = reutilización (2a); Encapsulamiento = protección/integridad (3c); Abstracción = manejo de complejidad (4d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione la tecnología web con su rol específico en una arquitectura de tres capas.\n**[Conjunto A] Tecnología**\n1. HTML/CSS/JS\n2. PHP\n3. MySQL\n4. REST\n**[Conjunto B] Rol**\na) Gestión y persistencia de datos estructurados.\nb) Lógica de negocio y procesamiento en el servidor.\nc) Interfaz de usuario y presentación en el cliente.\nd) Protocolo de interfaz para la comunicación entre capas o sistemas.",
    "opciones": {
      "A": "1c, 2b, 3a, 4d",
      "B": "1b, 2c, 3d, 4a",
      "C": "1c, 2a, 3b, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "Front-end (1c), Back-end/Lógica (2b), Persistencia/BD (3a), Comunicación/Interoperabilidad (4d)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione la técnica de paso de parámetros con su efecto en la memoria y la variable original.\n**[Conjunto A] Técnica**\n1. Paso por Valor\n2. Paso por Referencia (puntero en C)\n3. Paso de Arreglo (en C)\n**[Conjunto B] Efecto**\na) Se pasa la dirección de memoria; los cambios afectan a la variable original.\nb) Se crea una copia local del dato; los cambios no afectan a la variable original.\nc) Se pasa la dirección del primer elemento; se comporta como referencia aunque sintácticamente parece valor.",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1a, 2b, 3c",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "Paso por Valor (1b): crea una copia. Paso por Referencia (2a): pasa la dirección (los cambios afectan al original). Paso de Arreglo en C (3c): pasa la dirección del primer elemento, comportándose como referencia."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Lenguajes de Programación",
    "pregunta": "Relacione el fragmento de código/diseño con el concepto avanzado de programación o patrón que ilustra.\n**[Conjunto A] Código/Diseño**\n1. `class Pato extends Ave { void volar() { ... } }`\n2. `List<Figura> lista; lista.add(new Circulo()); lista.get(0).dibujar();`\n3. `try { ... } catch (Exception e) { ... }`\n4. `function(x) { return x + y; }` (donde `y` es externa y cambia)\n**[Conjunto B] Concepto**\na) Polimorfismo dinámico (binding tardío).\nb) Manejo de excepciones (robustez).\nc) Función impura (efecto secundario / dependencia de estado externo).\nd) Herencia simple.",
    "opciones": {
      "A": "1d, 2a, 3b, 4c",
      "B": "1a, 2d, 3c, 4b",
      "C": "1d, 2b, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-d: `extends` denota herencia simple. 2-a: Usar una referencia genérica para operar una instancia específica es polimorfismo. 3-b: `try-catch` es manejo de excepciones. 4-c: Una función que depende de variables externas mutables no es una función pura."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "¿Qué sentencia SQL se utiliza para modificar la estructura de una tabla existente, por ejemplo, para añadir una nueva columna?",
    "opciones": {
      "A": "UPDATE TABLE",
      "B": "ALTER TABLE",
      "C": "MODIFY TABLE"
    },
    "respuesta_correcta": "B",
    "justificacion": "Según el estándar SQL, `ALTER TABLE` es el comando DDL correcto para modificar la definición de una tabla base."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "En el modelo relacional, ¿cómo se denomina a la restricción que establece que ninguna clave primaria puede tener un valor NULO?",
    "opciones": {
      "A": "Integridad Referencial",
      "B": "Integridad de Dominio",
      "C": "Integridad de Entidad"
    },
    "respuesta_correcta": "C",
    "justificacion": "La regla de **Integridad de Entidad** establece que ningún valor de clave primaria puede ser NULL, ya que la clave primaria se usa para identificar tuplas individuales."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "¿Cuál es el objetivo principal de aplicar la Primera Forma Normal (1FN) a una relación?",
    "opciones": {
      "A": "Eliminar dependencias transitivas",
      "B": "Asegurar la atomicidad de los atributos",
      "C": "Eliminar dependencias parciales"
    },
    "respuesta_correcta": "B",
    "justificacion": "La definición de **1FN** establece que el dominio de un atributo debe incluir solo valores atómicos (simples e indivisibles), eliminando grupos repetitivos o atributos multivaluados."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "En un diagrama Entidad-Relación, ¿qué representa un rombo?",
    "opciones": {
      "A": "Un tipo de Entidad",
      "B": "Un tipo de Relación",
      "C": "Un Atributo derivado"
    },
    "respuesta_correcta": "B",
    "justificacion": "En la notación estándar ER (Chen), los **rombos** representan tipos de relación entre entidades."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "En el contexto de bases de datos distribuidas, si se divide una relación `ALUMNOS` seleccionando solo aquellos registros donde la carrera sea \"Sistemas\", ¿qué tipo de fragmentación se está aplicando?",
    "opciones": {
      "A": "Fragmentación Vertical",
      "B": "Fragmentación Horizontal",
      "C": "Fragmentación Mixta"
    },
    "respuesta_correcta": "B",
    "justificacion": "La **fragmentación horizontal** divide una relación en subconjuntos de tuplas (filas) mediante una operación de selección ($\\sigma$) basada en una condición (ej. Carrera = 'Sistemas')."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Una relación está en Tercera Forma Normal (3FN) si está en 2FN y además:",
    "opciones": {
      "A": "Todos sus atributos son atómicos.",
      "B": "No existen dependencias funcionales transitivas de atributos no clave hacia la clave primaria.",
      "C": "Todo determinante es una clave candidata."
    },
    "respuesta_correcta": "B",
    "justificacion": "La definición de **3FN** requiere eliminar las dependencias transitivas, donde un atributo no clave depende de otro atributo no clave. La opción C corresponde a BCNF."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "¿Cuál es la diferencia fundamental entre un sistema OLTP (Procesamiento de Transacciones en Línea) y un Data Warehouse?",
    "opciones": {
      "A": "OLTP es para datos históricos y Data Warehouse para datos actuales.",
      "B": "OLTP se orienta a aplicaciones operativas y Data Warehouse a la toma de decisiones.",
      "C": "OLTP utiliza esquemas en estrella y Data Warehouse esquemas normalizados."
    },
    "respuesta_correcta": "B",
    "justificacion": "Los sistemas **OLTP** están optimizados para transacciones diarias y rápidas (operacionales). El **Data Warehouse** almacena datos históricos, integrados y no volátiles para el análisis y soporte a decisiones (OLAP)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "¿Qué propiedad de las transacciones (ACID) garantiza que, una vez confirmada una transacción, sus cambios persisten incluso ante fallos del sistema?",
    "opciones": {
      "A": "Atomicidad",
      "B": "Aislamiento",
      "C": "Durabilidad"
    },
    "respuesta_correcta": "C",
    "justificacion": "La **Durabilidad** asegura que los cambios de una transacción confirmada (committed) deben persistir en la base de datos y no perderse por fallos posteriores."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Complete la sentencia SQL para obtener el nombre de los empleados que ganan más de 20,000:\n`SELECT Nombre ____ EMPLEADO ____ Sueldo > 20000;`",
    "opciones": {
      "A": "IN - IF",
      "B": "FROM - WHERE",
      "C": "ON - HAVING"
    },
    "respuesta_correcta": "B",
    "justificacion": "La estructura básica de consulta SQL es `SELECT ... FROM ... WHERE`. `FROM` especifica la tabla y `WHERE` la condición de filtrado de filas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Una **_______** es una columna o conjunto de columnas en una tabla cuyos valores coinciden con los valores de la clave primaria de otra tabla, estableciendo una relación entre ambas.",
    "opciones": {
      "A": "Clave Candidata",
      "B": "Clave Foránea (Foreign Key)",
      "C": "Superclave"
    },
    "respuesta_correcta": "B",
    "justificacion": "La **Clave Foránea** es el mecanismo del modelo relacional para establecer relaciones entre tablas, referenciando la clave primaria de otra tabla."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "El modelo **_______** representa los datos como una colección de tablas, donde cada tabla tiene un nombre único y consiste en filas y columnas.",
    "opciones": {
      "A": "Entidad-Relación",
      "B": "Jerárquico",
      "C": "Relacional"
    },
    "respuesta_correcta": "C",
    "justificacion": "El **Modelo Relacional** se define por el uso de relaciones (tablas) para representar datos y las asociaciones entre ellos."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "La operación del álgebra relacional que produce un conjunto con todas las tuplas que están en la relación R o en la relación S (o en ambas) se denomina **_______** y se denota como $R \\cup S$.",
    "opciones": {
      "A": "Intersección",
      "B": "Unión",
      "C": "Diferencia"
    },
    "respuesta_correcta": "B",
    "justificacion": "La **Unión** ($\\cup$) es la operación de conjuntos que combina tuplas de dos relaciones compatibles, incluyendo aquellas presentes en una, en otra o en ambas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Para reconstruir la relación original R a partir de sus fragmentos obtenidos por **fragmentación vertical**, se debe utilizar la operación de **_______** sobre el atributo de clave primaria que se replicó en todos los fragmentos.",
    "opciones": {
      "A": "Unión (Union)",
      "B": "Junta Natural (Natural Join)",
      "C": "Selección (Select)"
    },
    "respuesta_correcta": "B",
    "justificacion": "En la fragmentación vertical, se dividen los atributos. Para reconstruir la tupla completa, se necesita hacer un **Join (Junta Natural)** utilizando la clave primaria que debe estar presente en todos los fragmentos verticales."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Un esquema de relación R está en **_______** si, y solo si, siempre que existe una dependencia funcional $X \\rightarrow A$ válida en R, entonces $X$ es una superclave de R.",
    "opciones": {
      "A": "Segunda Forma Normal (2FN)",
      "B": "Tercera Forma Normal (3FN)",
      "C": "Forma Normal de Boyce-Codd (BCNF)"
    },
    "respuesta_correcta": "C",
    "justificacion": "Esta es la definición formal de **BCNF** (Forma Normal de Boyce-Codd), que es más estricta que la 3FN."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "En el contexto de bases de datos distribuidas, la transparencia de **_______** permite al usuario acceder a los datos sin saber si están particionados o replicados en diferentes nodos.",
    "opciones": {
      "A": "Ubicación",
      "B": "Fragmentación",
      "C": "Concurrencia"
    },
    "respuesta_correcta": "B",
    "justificacion": "La **transparencia de fragmentación** asegura que el usuario no necesita saber cómo están fragmentados los datos (si es horizontal o vertical) ni dónde residen los fragmentos; el sistema maneja la reconstrucción automáticamente."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "El proceso conocido como **_______** (Knowledge Discovery in Databases) incluye etapas de selección, preprocesamiento, transformación, minería de datos e interpretación.",
    "opciones": {
      "A": "KDD",
      "B": "ETL",
      "C": "OLAP"
    },
    "respuesta_correcta": "A",
    "justificacion": "**KDD** es el proceso general de descubrimiento de conocimiento (Knowledge Discovery in Databases), del cual la minería de datos es una fase específica."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione la operación del álgebra relacional con su símbolo y descripción.\n**[Operación]**\n1. Selección\n2. Proyección\n3. Producto Cartesiano\n4. Junta (Join)\n**[Descripción/Símbolo]**\na) $\\bowtie$ Combina tuplas relacionadas de dos relaciones.\nb) $\\sigma$ Selecciona filas que cumplen una condición.\nc) $\\pi$ Selecciona columnas específicas.\nd) $\\times$ Combina cada fila de una tabla con todas las de otra.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1c, 2b, 3a, 4d",
      "C": "1b, 2a, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Selección ($\\sigma$) filtra filas. 2-c: Proyección ($\\pi$) filtra columnas. 3-d: Producto cartesiano ($\\times$) es la combinatoria total. 4-a: Join ($\\bowtie$) combina basado en una condición."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione el tipo de restricción de integridad con su definición.\n**[Restricción]**\n1. De Dominio\n2. De Entidad\n3. Referencial\n**[Definición]**\na) La clave primaria no puede ser NULL.\nb) Una clave foránea debe coincidir con una clave primaria existente o ser NULL.\nc) El valor de un atributo debe pertenecer al conjunto de valores permitidos (tipo de dato).",
    "opciones": {
      "A": "1a, 2b, 3c",
      "B": "1c, 2a, 3b",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: Dominio define los valores válidos. 2-a: Integridad de Entidad (PK $\\neq$ NULL). 3-b: Integridad Referencial (FK consistency)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione el comando SQL con su sub-lenguaje correspondiente.\n**[Comando]**\n1. CREATE\n2. SELECT\n3. GRANT\n4. INSERT\n**[Tipo]**\na) DCL (Data Control Language)\nb) DDL (Data Definition Language)\nc) DML (Data Manipulation Language)",
    "opciones": {
      "A": "1b, 2c, 3a, 4c",
      "B": "1a, 2b, 3c, 4b",
      "C": "1b, 2a, 3c, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: CREATE define estructura (DDL). 2-c: SELECT consulta datos (DML). 3-a: GRANT controla permisos (DCL). 4-c: INSERT manipula datos (DML)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione el componente del modelo ER con su representación gráfica.\n**[Componente]**\n1. Entidad\n2. Atributo\n3. Relación\n4. Atributo Multivaluado\n**[Gráfico]**\na) Elipse con doble borde\nb) Rectángulo\nc) Rombo\nd) Elipse",
    "opciones": {
      "A": "1b, 2d, 3c, 4a",
      "B": "1c, 2a, 3b, 4d",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "Entidad=Rectángulo (1b), Atributo=Elipse (2d), Relación=Rombo (3c), Multivaluado=Elipse doble (4a)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione la función de agregación SQL con su propósito.\n**[Función]**\n1. COUNT\n2. SUM\n3. AVG\n4. MAX\n**[Propósito]**\na) Calcula el promedio de una columna numérica.\nb) Devuelve el valor más alto.\nc) Cuenta el número de filas.\nd) Suma los valores de una columna.",
    "opciones": {
      "A": "1c, 2d, 3b, 4a",
      "B": "1c, 2d, 3a, 4b",
      "C": "1d, 2a, 3c, 4b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: COUNT (conteo). 2-d: SUM (suma). 3-a: AVG (promedio). 4-b: MAX (máximo)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione el problema de diseño relacional con la Forma Normal que lo soluciona directamente.\n**[Problema]**\n1. Grupos repetitivos (atributos no atómicos).\n2. Dependencia parcial (atributo no clave depende de parte de la clave primaria).\n3. Dependencia transitiva (atributo no clave depende de otro no clave).\n**[Forma Normal]**\na) 2FN\nb) 3FN\nc) 1FN",
    "opciones": {
      "A": "1c, 2b, 3a",
      "B": "1c, 2a, 3b",
      "C": "1a, 2c, 3b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: La **1FN** elimina grupos repetitivos/no atómicos. 2-a: La **2FN** elimina dependencias parciales. 3-b: La **3FN** elimina dependencias transitivas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione el tipo de fragmentación en bases de datos distribuidas con la operación de álgebra relacional utilizada para crearla y para reconstruirla.\n**[Tipo de Fragmentación]**\n1. Horizontal\n2. Vertical\n**[Operaciones (Crear / Reconstruir)]**\na) Proyección ($\\pi$) / Junta Natural ($\\bowtie$)\nb) Selección ($\\sigma$) / Unión ($\\cup$)\nc) Producto Cartesiano / Intersección",
    "opciones": {
      "A": "1b, 2a",
      "B": "1a, 2b",
      "C": "1b, 2c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: La fragmentación **horizontal** usa `Selección` para dividir filas y `Unión` para unir. 2-a: La fragmentación **vertical** usa `Proyección` para dividir columnas y `Join` para reconstruir."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione los conceptos de Data Warehouse con su descripción técnica.\n**[Concepto]**\n1. Esquema en Estrella\n2. OLAP\n3. Data Mart\n**[Descripción]**\na) Almacén de datos departamental o especializado en un subconjunto del negocio.\nb) Diseño con una tabla de hechos central y tablas de dimensiones desnormalizadas.\nc) Tecnología que permite análisis multidimensional rápido de grandes volúmenes de datos.",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1c, 2a, 3b",
      "C": "1b, 2a, 3c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: **Esquema en Estrella** (Star Schema) es un diseño característico de DW. 2-c: **OLAP** es la tecnología de análisis. 3-a: **Data Mart** es una versión más pequeña/especializada del DW."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Bases de Datos",
    "pregunta": "Relacione los requerimientos con la técnica adecuada.\n**[Requerimiento]**\n1. Fragmentación para Sede A (solo estudiantes de \"Sistemas\")\n2. Fragmentación para Sede B (solo nombres y promedios)\n3. Control de Concurrencia\n4. Reconstrucción de datos de Sede A para vista global\n**[Técnica]**\na) Fragmentación Vertical\nb) Fragmentación Horizontal ($\\sigma_{Carrera='Sistemas'}$)\nc) Unión ($\\cup$)\nd) Bloqueo en Dos Fases (2PL) o Timestamping",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2c, 3d, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Sede A necesita filtrar filas por condición (Horizontal). 2-a: Sede B necesita subconjunto de columnas (Vertical). 3-d: El control de concurrencia en sistemas distribuidos usa 2PL o estampas de tiempo. 4-c: La fragmentación horizontal se reconstruye con Unión."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Un desarrollador necesita asegurar que los mensajes enviados entre dos sucursales bancarias no sean leídos por interceptores en la red pública. ¿Qué propiedad de la seguridad informática debe priorizar?",
    "opciones": {
      "A": "Integridad",
      "B": "Disponibilidad",
      "C": "Confidencialidad"
    },
    "respuesta_correcta": "C",
    "justificacion": "La confidencialidad se refiere específicamente a prevenir que la información sea revelada a entidades no autorizadas (como interceptores)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "En el contexto de seguridad informática, ¿cómo se define una vulnerabilidad?",
    "opciones": {
      "A": "Es una debilidad en el sistema que permite a un atacante reducir la seguridad de la información.",
      "B": "Es un evento potencial que puede causar daño a los activos de la organización.",
      "C": "Es la probabilidad de que una amenaza se materialice causando un impacto negativo."
    },
    "respuesta_correcta": "A",
    "justificacion": "Una vulnerabilidad es una debilidad intrínseca (fallo de diseño, error de código). La opción B define una amenaza y la C define un riesgo."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "¿Qué tipo de malware se caracteriza por ser un programa que aparenta tener una función útil pero que contiene código malicioso oculto que se ejecuta al iniciar el programa?",
    "opciones": {
      "A": "Gusano (Worm)",
      "B": "Caballo de Troya",
      "C": "Virus polimórfico"
    },
    "respuesta_correcta": "B",
    "justificacion": "El Caballo de Troya se define por disfrazarse de software legítimo para engañar al usuario y ejecutar acciones maliciosas."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Para proteger una base de datos de accesos no autorizados, el administrador decide implementar un sistema donde el acceso a los objetos se basa en la identidad del usuario y reglas explícitas definidas por el propietario del objeto. ¿Qué tipo de control de acceso es este?",
    "opciones": {
      "A": "Control de Acceso Obligatorio (MAC)",
      "B": "Control de Acceso Discrecional (DAC)",
      "C": "Control de Acceso Basado en Roles (RBAC)"
    },
    "respuesta_correcta": "B",
    "justificacion": "En el DAC (Discretionary Access Control), el propietario del recurso tiene la discreción de otorgar o revocar permisos a otros usuarios."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Una empresa de comercio electrónico desea implementar un sistema de no repudio para sus transacciones de alto valor. ¿Qué mecanismo criptográfico garantiza que el emisor de una orden de compra no pueda negar posteriormente haberla enviado?",
    "opciones": {
      "A": "Cifrado simétrico con AES-256",
      "B": "Firma digital utilizando la clave privada del emisor",
      "C": "Hash MD5 del mensaje de la orden"
    },
    "respuesta_correcta": "B",
    "justificacion": "La firma digital proporciona autenticidad, integridad y **no repudio**. Al firmar con la clave privada (que solo el emisor posee), se garantiza matemáticamente que solo él pudo generar la firma."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Durante una auditoría de código, se identifica que una aplicación web concatena directamente las entradas del usuario en las cadenas de consulta a la base de datos sin validación. ¿A qué vulnerabilidad crítica está expuesta la aplicación y cuál es la mitigación correcta?",
    "opciones": {
      "A": "Cross-Site Scripting (XSS); usar HTTPS.",
      "B": "Desbordamiento de búfer; usar canarios de pila.",
      "C": "Inyección SQL; usar consultas parametrizadas (prepared statements)."
    },
    "respuesta_correcta": "C",
    "justificacion": "La concatenación directa de entradas en consultas SQL permite la Inyección SQL. La solución técnica estándar es el uso de consultas parametrizadas donde la entrada se trata estrictamente como datos."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Un sistema crítico de control industrial requiere que la información fluya únicamente desde niveles de seguridad bajos hacia niveles altos para mantener la confidencialidad (modelo Bell-LaPadula). Si un proceso tiene un nivel de seguridad \"Secreto\", ¿qué operación le está permitida sobre un objeto clasificado como \"Top Secret\"?",
    "opciones": {
      "A": "Lectura (Read Up)",
      "B": "Escritura (Write Up)",
      "C": "Ejecución y modificación"
    },
    "respuesta_correcta": "B",
    "justificacion": "El modelo Bell-LaPadula aplica la regla \"No Read Up\" (no leer niveles superiores) y \"No Write Down\" (no escribir en niveles inferiores). Un proceso de nivel inferior (Secreto) puede **escribir hacia arriba** (Top Secret) sin violar la confidencialidad del nivel superior."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Se está diseñando una base de datos distribuida con requisitos estrictos de seguridad. Se debe implementar un control donde los permisos se asignen a funciones laborales y los usuarios hereden estos permisos al ser asignados a dichas funciones. ¿Cuál es la ventaja principal de este modelo (RBAC) sobre DAC en una organización con alta rotación de personal?",
    "opciones": {
      "A": "Permite que los usuarios definan sus propias políticas de seguridad de manera flexible.",
      "B": "Reduce la carga administrativa al gestionar permisos por grupos funcionales en lugar de usuario por usuario.",
      "C": "Garantiza que los datos estén etiquetados con niveles de sensibilidad obligatorios por el sistema operativo."
    },
    "respuesta_correcta": "B",
    "justificacion": "RBAC (Role-Based Access Control) facilita la gestión en grandes organizaciones. Al cambiar de personal, solo se cambia la asignación del usuario al rol, sin necesidad de reconfigurar los permisos de cada objeto individualmente."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "En el análisis de riesgos de seguridad informática, se define **_______** como la probabilidad de que una amenaza explote una vulnerabilidad causando una pérdida.",
    "opciones": {
      "A": "el impacto",
      "B": "el activo",
      "C": "el riesgo"
    },
    "respuesta_correcta": "C",
    "justificacion": "El riesgo es el producto de la probabilidad de ocurrencia por el impacto. La definición dada corresponde exactamente al concepto de riesgo en seguridad."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Un ataque de **_______** consiste en saturar los recursos de un sistema (como ancho de banda o capacidad de procesamiento) para que este deje de responder a las peticiones legítimas de los usuarios.",
    "opciones": {
      "A": "denegación de servicio (DoS)",
      "B": "phishing",
      "C": "inyección de código"
    },
    "respuesta_correcta": "A",
    "justificacion": "El objetivo de un ataque DoS (Denial of Service) es comprometer la disponibilidad del sistema saturándolo, impidiendo el acceso legítimo."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "El protocolo **_______** es una versión segura de HTTP que utiliza SSL/TLS para cifrar la comunicación entre el navegador web y el servidor, garantizando la confidencialidad de los datos transmitidos.",
    "opciones": {
      "A": "SFTP",
      "B": "HTTPS",
      "C": "IPSec"
    },
    "respuesta_correcta": "B",
    "justificacion": "HTTPS (Hypertext Transfer Protocol Secure) es el estándar para la navegación web segura mediante cifrado (usando SSL/TLS)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Para garantizar la integridad de un archivo descargado de internet, se suele comparar su **_______** calculado con el valor proporcionado por el desarrollador original.",
    "opciones": {
      "A": "cifrado asimétrico",
      "B": "resumen hash (checksum)",
      "C": "certificado digital"
    },
    "respuesta_correcta": "B",
    "justificacion": "Las funciones hash (como MD5 o SHA-256) generan una cadena única (resumen) para un archivo. El hash es usado para verificar la integridad."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "En un esquema de Criptografía de Clave Pública (PKI), si el Usuario A desea enviar un mensaje confidencial al Usuario B, el Usuario A debe cifrar el mensaje utilizando la **_______**, y el Usuario B lo descifrará utilizando su **_______**.",
    "opciones": {
      "A": "clave pública de B / clave privada de B",
      "B": "clave privada de A / clave pública de A",
      "C": "clave pública de A / clave privada de B"
    },
    "respuesta_correcta": "A",
    "justificacion": "Para confidencialidad en criptografía asimétrica, se cifra con la clave pública del destinatario (B) para que solo el destinatario con su clave privada (B) pueda leerlo."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "La técnica de **_______** implica la inserción de instrucciones \"no-operation\" (NOP) seguidas de código malicioso en la pila de memoria, aprovechando una vulnerabilidad de desbordamiento de búfer para alterar el puntero de instrucción y ejecutar el código inyectado.",
    "opciones": {
      "A": "cross-site scripting",
      "B": "buffer overflow (desbordamiento de búfer)",
      "C": "man-in-the-middle"
    },
    "respuesta_correcta": "B",
    "justificacion": "Esta es la mecánica técnica precisa de un ataque de desbordamiento de búfer clásico (stack-based buffer overflow), donde se sobrescribe la dirección de retorno para apuntar al shellcode del atacante."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Un firewall con **_______** no solo examina las cabeceras de los paquetes individuales, sino que también mantiene un registro de las conexiones activas (TCP handshake) para tomar decisiones de filtrado basadas en el contexto de la comunicación.",
    "opciones": {
      "A": "filtrado de paquetes estático",
      "B": "inspección de estado (stateful inspection)",
      "C": "proxy de aplicación"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los firewalls de inspección de estado (stateful) monitorean el estado de las conexiones activas y usan esa información para determinar qué paquetes de red permitir a través del firewall."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "En el contexto de la seguridad de bases de datos, el principio de **_______** establece que a un usuario o proceso solo se le deben otorgar los permisos estrictamente necesarios para realizar su trabajo y nada más.",
    "opciones": {
      "A": "defensa en profundidad",
      "B": "mínimo privilegio",
      "C": "seguridad por oscuridad"
    },
    "respuesta_correcta": "B",
    "justificacion": "El principio de mínimo privilegio es fundamental en el diseño de sistemas seguros para limitar el daño potencial en caso de un compromiso de cuenta."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione los conceptos de seguridad con su descripción básica.\n**Conceptos**\n1. Confidencialidad\n2. Integridad\n3. Disponibilidad\n**Descripción**\na) Garantía de que el sistema funciona y los servicios no son negados a usuarios autorizados.\nb) Protección contra la modificación no autorizada de datos.\nc) Protección contra la divulgación no autorizada de información.",
    "opciones": {
      "A": "1a, 2b, 3c",
      "B": "1c, 2b, 3a",
      "C": "1b, 2a, 3c"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: Confidencialidad = No divulgación. 2-b: Integridad = No modificación. 3-a: Disponibilidad = Acceso garantizado."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione el tipo de malware con su característica principal.\n**Malware**\n1. Virus\n2. Gusano\n3. Spyware\n**Característica**\na) Se replica a través de redes sin necesitar un archivo anfitrión.\nb) Recopila información del usuario sin su consentimiento.\nc) Inserta su código en otros archivos ejecutables para propagarse.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1a, 2b, 3c",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Virus requiere anfitrión (archivo). 2-a: Gusano es autónomo en red. 3-b: Spyware espía/recopila datos."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione los mecanismos de control de acceso con su definición.\n**Mecanismo**\n1. Identificación\n2. Autenticación\n3. Autorización\n**Definición**\na) Verificar que el usuario es quien dice ser (ej. password).\nb) Determinar qué recursos puede usar el usuario verificado.\nc) El usuario declara quién es (ej. nombre de usuario).",
    "opciones": {
      "A": "1a, 2c, 3b",
      "B": "1c, 2a, 3b",
      "C": "1b, 2a, 3c"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: Identificación es decir quién eres. 2-a: Autenticación es probarlo. 3-b: Autorización es otorgar permisos."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione el tipo de amenaza con la categoría de activo afectado.\n**Amenaza**\n1. Intercepción (Sniffing)\n2. Modificación de datos\n3. Interrupción (DoS)\n**Activo Afectado**\na) Disponibilidad\nb) Confidencialidad\nc) Integridad",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Interceptar rompe la confidencialidad. 2-c: Modificar rompe la integridad. 3-a: Interrumpir rompe la disponibilidad."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione los términos de criptografía básica.\n**Término**\n1. Texto plano\n2. Texto cifrado\n3. Algoritmo de cifrado\n4. Clave\n**Descripción**\na) El resultado ininteligible del proceso.\nb) El mensaje original legible.\nc) Información secreta usada para personalizar la transformación.\nd) Función matemática usada para encriptar.",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2a, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Texto plano es el original. 2-a: Texto cifrado es el resultado. 3-d: Algoritmo es la función matemática. 4-c: Clave es el secreto variable."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione los modelos de seguridad con su objetivo principal.\n**Modelo**\n1. Bell-LaPadula\n2. Biba\n3. Clark-Wilson\n**Objetivo**\na) Enfocado en la integridad de datos comerciales y reglas de consistencia.\nb) Enfocado estrictamente en la confidencialidad (niveles de clasificación).\nc) Enfocado estrictamente en la integridad (prevenir modificación no autorizada).",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Bell-LaPadula es el modelo clásico de confidencialidad militar. 2-c: Biba es el inverso, enfocado en integridad de niveles. 3-a: Clark-Wilson se enfoca en transacciones bien formadas e integridad comercial."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione el tipo de ataque web con la técnica de mitigación más efectiva.\n**Ataque**\n1. SQL Injection\n2. Cross-Site Scripting (XSS)\n3. Brute Force (Login)\n**Mitigación**\na) Bloqueo de cuenta tras N intentos fallidos o retardos progresivos.\nb) Uso de Prepared Statements (Consultas parametrizadas).\nc) Escapado de caracteres de salida (Output encoding) y validación de entrada.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1b, 2c, 3a",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: La inyección SQL se evita separando datos de comandos mediante parámetros. 2-c: XSS se evita asegurando que el navegador no interprete datos como scripts. 3-a: Fuerza bruta se mitiga limitando los intentos."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione los protocolos de seguridad de red con la capa del modelo OSI donde operan principalmente.\n**Protocolo**\n1. WPA2 (Wi-Fi)\n2. IPSec\n3. TLS/SSL\n4. PGP (Email)\n**Capa OSI**\na) Capa de Transporte / Sesión\nb) Capa de Aplicación\nc) Capa de Enlace de Datos\nd) Capa de Red",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1d, 2c, 3b, 4a",
      "C": "1a, 2b, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: WPA2 asegura el enlace inalámbrico (Enlace). 2-d: IPSec asegura paquetes IP (Red). 3-a: TLS opera sobre TCP (Transporte/Sesión). 4-b: PGP asegura el contenido del correo (Aplicación)."
  },
  {
    "tema": "Desarrollo de Software de Aplicación - Seguridad Informática",
    "pregunta": "Relacione la vulnerabilidad de seguridad con el principio de diseño violado y el impacto potencial en una base de datos distribuida.\n**Vulnerabilidad**\n1. Almacenar contraseñas en texto plano en la base de datos.\n2. Permitir que un usuario \"Invitado\" tenga permisos de `DROP TABLE`.\n3. No cifrar la replicación de datos entre nodos distribuidos a través de Internet.\n**Principio Violado / Impacto**\na) Violación de Mínimo Privilegio / Pérdida de Disponibilidad e Integridad.\nb) Violación de Defensa en Profundidad / Compromiso total de cuentas si hay una filtración.\nc) Violación de Protección de Datos en Tránsito / Pérdida de Confidencialidad por Sniffing.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1b, 2a, 3c",
      "C": "1a, 2b, 3c"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: Guardar contraseñas en texto plano es un fallo de defensa en profundidad. 2-a: Invitado con `DROP` viola el mínimo privilegio. 3-c: Datos sin cifrar en red pública viola la protección en tránsito, lo que provoca pérdida de confidencialidad por Sniffing."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "¿Cuál es la etapa del proceso de Descubrimiento de Conocimiento en Bases de Datos (KDD) que se encarga de la eliminación de ruido y el manejo de datos faltantes?",
    "opciones": {
      "A": "Selección",
      "B": "Preprocesamiento",
      "C": "Transformación"
    },
    "respuesta_correcta": "B",
    "justificacion": "El preprocesamiento incluye la limpieza de datos, que abarca el manejo de valores faltantes, eliminación de ruido y corrección de inconsistencias, preparando los datos para la minería."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "En el contexto de los agentes inteligentes, ¿qué término describe la medida que evalúa qué tan exitoso es un agente en completar su tarea?",
    "opciones": {
      "A": "Función de utilidad",
      "B": "Medida de rendimiento",
      "C": "Modelo de transición"
    },
    "respuesta_correcta": "B",
    "justificacion": "La medida de rendimiento (Performance measure) es el criterio objetivo para evaluar el éxito del comportamiento de un agente."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "¿Qué tipo de lógica permite representar conceptos vagos o imprecisos, asignando grados de pertenencia a los conjuntos, como \"temperatura media\" o \"velocidad alta\"?",
    "opciones": {
      "A": "Lógica de primer orden",
      "B": "Lógica proposicional",
      "C": "Lógica difusa"
    },
    "respuesta_correcta": "C",
    "justificacion": "La lógica difusa utiliza funciones de membresía para asignar grados de verdad entre 0 y 1, permitiendo modelar la incertidumbre asociada a la vaguedad del lenguaje natural."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "En una Red Neuronal Artificial, ¿cuál es el propósito del algoritmo de _Backpropagation_ (propagación hacia atrás)?",
    "opciones": {
      "A": "Definir la topología de la red",
      "B": "Calcular el error y ajustar los pesos",
      "C": "Normalizar los datos de entrada"
    },
    "respuesta_correcta": "B",
    "justificacion": "_Backpropagation_ es el algoritmo estándar para el aprendizaje en redes multicapa. Calcula el gradiente del error respecto a los pesos y los ajusta para minimizar dicho error."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Dados dos objetos representados por los vectores de características $A = (2, 5)$ y $B = (5, 1)$, calcule la distancia euclidiana entre ellos.",
    "opciones": {
      "A": "5",
      "B": "7",
      "C": "25"
    },
    "respuesta_correcta": "A",
    "justificacion": "La fórmula es $\\sqrt{(x_2-x_1)^2 + (y_2-y_1)^2}$. Cálculo: $\\sqrt{(5-2)^2 + (1-5)^2} = \\sqrt{3^2 + (-4)^2} = \\sqrt{9 + 16} = \\sqrt{25} = 5$."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Un sistema de diagnóstico médico utiliza un motor de inferencia. El sistema comienza con la hipótesis de que el paciente tiene \"Gripe\" y busca en su base de reglas los síntomas que confirman esa enfermedad para luego preguntar al paciente si los presenta. ¿Qué estrategia de control está utilizando?",
    "opciones": {
      "A": "Encadenamiento hacia adelante",
      "B": "Encadenamiento hacia atrás",
      "C": "Búsqueda en amplitud"
    },
    "respuesta_correcta": "B",
    "justificacion": "El encadenamiento hacia atrás (goal-driven) comienza con una hipótesis (objetivo) y trabaja hacia atrás buscando reglas que la soporten hasta llegar a los hechos (datos) necesarios."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Al diseñar un sistema de cómputo distribuido tolerante a fallas para procesar grandes volúmenes de datos de IA, ¿qué técnica es la más adecuada para asegurar que el sistema continúe operando si un nodo falla durante el procesamiento?",
    "opciones": {
      "A": "Replicación de estado",
      "B": "Checkpointing local",
      "C": "Exclusión mutua"
    },
    "respuesta_correcta": "A",
    "justificacion": "La replicación (específicamente la replicación activa o de estado) permite que múltiples copias de un componente procesen la misma solicitud, asegurando disponibilidad inmediata si uno falla."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Se tiene un conjunto de datos con una alta dimensionalidad (100 atributos) y pocos registros. Se desea aplicar un clasificador, pero se teme el sobreajuste. ¿Qué técnica de preprocesamiento es la más indicada antes de entrenar el modelo?",
    "opciones": {
      "A": "Discretización",
      "B": "Selección de características (Feature Selection)",
      "C": "Sobremuestreo (Oversampling)"
    },
    "respuesta_correcta": "B",
    "justificacion": "La selección de características reduce la dimensionalidad eliminando atributos irrelevantes o redundantes, lo cual ayuda a mitigar la \"maldición de la dimensionalidad\" y el riesgo de sobreajuste cuando hay pocos datos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "El aprendizaje **_______** es un tipo de aprendizaje automático donde el modelo se construye a partir de un conjunto de datos que contiene tanto las entradas como las etiquetas de salida deseadas.",
    "opciones": {
      "A": "por refuerzo",
      "B": "supervisado",
      "C": "no supervisado"
    },
    "respuesta_correcta": "B",
    "justificacion": "En el aprendizaje supervisado, el agente observa pares de ejemplo (entrada, salida) y aprende una función que mapea de la entrada a la salida."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "En la arquitectura de un Sistema Experto, la **_______** contiene los hechos y reglas específicas del dominio que se está modelando, separada del motor de inferencia.",
    "opciones": {
      "A": "interfaz de usuario",
      "B": "memoria de trabajo",
      "C": "base de conocimientos"
    },
    "respuesta_correcta": "C",
    "justificacion": "La base de conocimientos es el componente que almacena el conocimiento especializado (reglas, hechos) en un sistema experto."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Para determinar la similitud entre dos documentos de texto representados como vectores de frecuencias de palabras, una métrica comúnmente utilizada que mide el coseno del ángulo entre ellos es la similitud **_______**.",
    "opciones": {
      "A": "de Jaccard",
      "B": "Coseno",
      "C": "Manhattan"
    },
    "respuesta_correcta": "B",
    "justificacion": "La similitud coseno es estándar en minería de texto para medir la similitud entre documentos, independiente de su longitud, basándose en la orientación de sus vectores."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "El servicio de cómputo en la nube conocido como **_______** proporciona a los desarrolladores un entorno para construir aplicaciones y servicios a través de internet, sin preocuparse por la infraestructura subyacente (servidores, almacenamiento, redes).",
    "opciones": {
      "A": "IaaS (Infraestructura como Servicio)",
      "B": "PaaS (Plataforma como Servicio)",
      "C": "SaaS (Software como Servicio)"
    },
    "respuesta_correcta": "B",
    "justificacion": "PaaS ofrece herramientas de desarrollo y despliegue a los desarrolladores, sin preocuparse por la infraestructura."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "En el algoritmo _K-Means_, el paso de asignación consiste en asignar cada punto de datos al **_______** más cercano según una medida de distancia, generalmente la euclidiana.",
    "opciones": {
      "A": "centroide",
      "B": "vecino",
      "C": "outlier"
    },
    "respuesta_correcta": "A",
    "justificacion": "K-Means itera entre asignar puntos al centroide (media del cluster) más cercano y recalcular los centroides basándose en los nuevos miembros del cluster."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Considere la regla lógica: \"Si el motor no arranca y las luces no encienden, entonces la batería está muerta\". En un sistema de encadenamiento hacia adelante, si se introducen los hechos \"El motor no arranca\" y \"Las luces no encienden\", el motor de inferencia **_______** la regla para concluir el estado de la batería.",
    "opciones": {
      "A": "rechazará",
      "B": "disparará (fire)",
      "C": "podará"
    },
    "respuesta_correcta": "B",
    "justificacion": "En sistemas de producción y encadenamiento hacia adelante, cuando las condiciones de una regla se cumplen (match), la regla se \"disparará\" para agregar la conclusión a la memoria de trabajo."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "El problema de la **_______** ocurre cuando múltiples hilos o procesos intentan acceder y modificar un recurso compartido al mismo tiempo, lo que puede resultar en datos inconsistentes si no se utilizan mecanismos de sincronización adecuados como semáforos.",
    "opciones": {
      "A": "condición de carrera",
      "B": "inanición (starvation)",
      "C": "exclusión mutua"
    },
    "respuesta_correcta": "A",
    "justificacion": "Una condición de carrera (race condition) sucede cuando el resultado de la ejecución depende del orden no determinista en que se ejecutan los hilos sobre recursos compartidos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Para evaluar un clasificador binario con clases desbalanceadas, la **_______** no es una métrica confiable. En su lugar, se debe utilizar la matriz de confusión para calcular precisión, recall o F1-score.",
    "opciones": {
      "A": "sensibilidad",
      "B": "exactitud (accuracy)",
      "C": "especificidad"
    },
    "respuesta_correcta": "B",
    "justificacion": "La exactitud puede ser engañosa en datos desbalanceados (ej. 99% clase A, 1% clase B; un modelo que siempre predice A tiene 99% de exactitud pero es inútil). Sensibilidad y especificidad son más robustas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione el tipo de agente inteligente con su descripción característica.\n**Tipo de Agente**\n1. Reactivo simple\n2. Basado en modelos\n3. Basado en objetivos\n4. Basado en utilidad\n**Descripción**\na) Toma decisiones basadas únicamente en el percepto actual, ignorando el historial.\nb) Mantiene un estado interno para rastrear aspectos del mundo que no son evidentes en el percepto actual.\nc) Utiliza información sobre situaciones deseables para guiar su toma de decisiones y planificar.\nd) Toma decisiones considerando una medida de preferencia entre estados para maximizar la felicidad o éxito.",
    "opciones": {
      "A": "1a, 2b, 3c, 4d",
      "B": "1b, 2a, 3d, 4c",
      "C": "1a, 2c, 3b, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Los reactivos simples actúan solo sobre la entrada actual (reglas condición-acción). 2-b: Los basados en modelos requieren memoria (estado interno) para manejar la observabilidad parcial. 3-c: Los basados en objetivos necesitan saber la meta para decidir la acción. 4-d: La utilidad permite comparar qué tan bueno es un estado o meta."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione las técnicas de Inteligencia Artificial con su aplicación principal.\n**Técnica**\n1. Lógica Difusa\n2. Redes Neuronales\n3. Algoritmos Genéticos\n4. Sistemas Expertos\n**Aplicación**\na) Diagnóstico médico basado en reglas explícitas definidas por humanos.\nb) Control de temperatura en un aire acondicionado (suave/medio/fuerte).\nc) Reconocimiento de imágenes y patrones complejos.\nd) Optimización de rutas y problemas de búsqueda evolutiva.",
    "opciones": {
      "A": "1b, 2c, 3d, 4a",
      "B": "1a, 2b, 3c, 4d",
      "C": "1c, 2d, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Lógica difusa es ideal para control suave y variables lingüísticas. 2-c: Redes neuronales sobresalen en reconocimiento de patrones perceptuales. 3-d: Algoritmos genéticos se usan para optimización y búsqueda evolutiva. 4-a: Sistemas expertos emulan la toma de decisiones de un experto humano mediante reglas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione el tipo de aprendizaje automático con el escenario descrito.\n**Tipo de Aprendizaje**\n1. Supervisado\n2. No Supervisado\n3. Por Refuerzo\n**Escenario**\na) Un programa de ajedrez aprende jugando millones de partidas contra sí mismo, recibiendo puntos al ganar.\nb) Un banco utiliza datos históricos de créditos (pagados/no pagados) para entrenar un modelo de riesgo.\nc) Un departamento de marketing segmenta a sus clientes en grupos basados en patrones de compra sin etiquetas previas.",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Datos históricos etiquetados implican aprendizaje supervisado. 2-c: Segmentación (clustering) sin etiquetas es no supervisado. 3-a: Aprender mediante premios/castigos en un entorno es aprendizaje por refuerzo."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione el concepto de KDD con su definición.\n**Concepto**\n1. Data Warehouse\n2. Limpieza de datos\n3. Minería de datos\n4. Interpretación\n**Definición**\na) Aplicación de algoritmos inteligentes para extraer patrones.\nb) Repositorio unificado de datos históricos para análisis.\nc) Evaluación de los patrones descubiertos para convertirlos en conocimiento útil.\nd) Proceso de remover inconsistencias y ruido de los datos.",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1d, 2a, 3c, 4b",
      "C": "1a, 2b, 3d, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Data Warehouse almacena datos integrados. 2-d: Limpieza es parte del preprocesamiento. 3-a: Minería es la etapa algorítmica de extracción. 4-c: Interpretación da sentido a los patrones."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione las compuertas lógicas con su comportamiento en lógica proposicional.\n**Compuerta**\n1. AND ($\\wedge$)\n2. OR ($\\vee$)\n3. NOT ($\\neg$)\n4. Implicación ($\\to$)\n**Comportamiento**\na) Verdadero solo si ambas entradas son verdaderas.\nb) Falso solo si la primera es verdadera y la segunda falsa.\nc) Invierte el valor de verdad.\nd) Falso solo si ambas entradas son falsas.",
    "opciones": {
      "A": "1a, 2d, 3c, 4b",
      "B": "1d, 2a, 3b, 4c",
      "C": "1a, 2b, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Conjunción. 2-d: Disyunción. 3-c: Negación. 4-b: La implicación $P \\to Q$ solo es falsa cuando $P$ es V y $Q$ es F."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione los algoritmos de clasificación con sus características distintivas de funcionamiento.\n**Algoritmo**\n1. Naive Bayes\n2. Árboles de Decisión (ID3/C4.5)\n3. K-Nearest Neighbors (K-NN)\n4. Support Vector Machines (SVM)\n**Característica**\na) Basado en el teorema de Bayes, asume independencia entre atributos.\nb) Busca el hiperplano que maximiza el margen de separación entre clases.\nc) Utiliza medidas de ganancia de información o entropía para dividir el espacio de datos.\nd) Clasifica una nueva instancia basándose en la clase mayoritaria de sus vecinos más cercanos en el espacio de características.",
    "opciones": {
      "A": "1a, 2c, 3d, 4b",
      "B": "1a, 2d, 3c, 4b",
      "C": "1c, 2a, 3b, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Naive Bayes asume independencia condicional. 2-c: Árboles usan entropía para crear divisiones (splits). 3-d: K-NN es un método basado en instancias (lazy learning). 4-b: SVM busca el margen máximo."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione el mecanismo de tolerancia a fallas en sistemas distribuidos con su descripción técnica.\n**Mecanismo**\n1. Checkpointing\n2. Replicación Pasiva (Primary-Backup)\n3. Replicación Activa (State Machine)\n4. Atomicidad (Transacciones)\n**Descripción**\na) Todas las réplicas procesan cada solicitud concurrentemente; requiere determinismo.\nb) Solo una réplica procesa la solicitud y actualiza a las demás; si falla, otra toma el control.\nc) Guardar periódicamente el estado del sistema en almacenamiento estable para recuperación.\nd) Propiedad que asegura que una operación se realiza completamente o no se realiza en absoluto.",
    "opciones": {
      "A": "1c, 2b, 3a, 4d",
      "B": "1d, 2a, 3b, 4c",
      "C": "1c, 2a, 3b, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Checkpointing guarda estados. 2-b: Pasiva implica un líder (primario) y respaldos. 3-a: Activa implica procesamiento paralelo en todas las réplicas. 4-d: Atomicidad es clave en transacciones distribuidas (ACID)."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Relacione el esquema de representación de conocimiento con su estructura y limitación principal.\n**Esquema**\n1. Redes Semánticas\n2. Marcos (Frames)\n3. Lógica de Predicados\n4. Reglas de Producción\n**Estructura/Limitación**\na) Estructura de grafos con nodos y arcos etiquetados; carece de semántica formal estandarizada para los enlaces.\nb) Estructura de objetos con ranuras (slots) y facetas; ideal para herencia y valores por defecto.\nc) Formalismo matemático preciso con cuantificadores; computacionalmente costoso e indecidible en casos generales.\nd) Estructura IF-THEN modular; puede ser difícil de mantener en sistemas muy grandes y propensa a conflictos.",
    "opciones": {
      "A": "1a, 2b, 3c, 4d",
      "B": "1b, 2a, 3d, 4c",
      "C": "1a, 2c, 3b, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Redes semánticas son grafos, sufren de ambigüedad en enlaces. 2-b: Marcos organizan conocimiento en objetos/clases. 3-c: Lógica de primer orden es potente pero semidecidible. 4-d: Reglas son modulares pero difíciles de gestionar a gran escala."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Inteligencia Artificial",
    "pregunta": "Un ingeniero debe diseñar un sistema de visión artificial distribuido para detectar defectos en líneas de manufactura. El sistema debe clasificar imágenes en tiempo real y tolerar la caída de sensores. Relacione los componentes del diseño con la justificación técnica adecuada para cumplir los requisitos.\n**Componente de Diseño**\n1. Algoritmo de Clasificación: Red Neuronal Convolucional (CNN)\n2. Preprocesamiento: Normalización de histograma\n3. Arquitectura Distribuida: Edge Computing\n4. Tolerancia a Fallas: Redundancia de Sensores y Votación\n**Justificación Técnica**\na) Permite procesar los datos cerca de la fuente (línea de manufactura) reduciendo la latencia para tiempo real.\nb) Estandariza el contraste y brillo de las imágenes para que el modelo sea robusto a cambios de iluminación.\nc) Método especializado en extraer características espaciales y patrones visuales complejos de imágenes crudas.\nd) Permite comparar salidas de múltiples fuentes; si un sensor falla o da datos erróneos, el sistema sigue operando por mayoría.",
    "opciones": {
      "A": "1c, 2b, 3a, 4d",
      "B": "1a, 2c, 3d, 4b",
      "C": "1b, 2a, 3c, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: CNN es el método para extraer características espaciales (imágenes). 2-b: Normalización de histograma estandariza el contraste/brillo. 3-a: Edge computing reduce la latencia procesando datos cerca de la fuente. 4-d: La votación con redundancia permite enmascarar fallas por mayoría."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "¿Cuál es el objetivo principal de la etapa de preprocesamiento dentro del proceso KDD?",
    "opciones": {
      "A": "Seleccionar los algoritmos de minería que se utilizarán.",
      "B": "Limpiar los datos de ruido y valores atípicos para mejorar su calidad.",
      "C": "Interpretar los patrones encontrados para la toma de decisiones."
    },
    "respuesta_correcta": "B",
    "justificacion": "El preprocesamiento y transformación tienen como objetivo realizar operaciones de limpieza, remover ruido y outliers, y tratar datos faltantes para el buen funcionamiento de los módulos siguientes."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "¿Qué término se utiliza para describir a los puntos de datos que se desvían significativamente de la mayoría de los datos en un dataset?",
    "opciones": {
      "A": "Clusters.",
      "B": "Raw data.",
      "C": "Outliers."
    },
    "respuesta_correcta": "C",
    "justificacion": "Los _outliers_ se definen como puntos fuera de la mayoría de los datos, los cuales suelen ser removidos durante el preprocesamiento."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "¿Cuál de las siguientes opciones es una tarea común de la minería de datos utilizada para asignar elementos a categorías predefinidas?",
    "opciones": {
      "A": "Clustering.",
      "B": "Clasificación.",
      "C": "Regresión."
    },
    "respuesta_correcta": "B",
    "justificacion": "La clasificación es una de las tareas más comunes cuyo objetivo es asignar datos a clases o categorías específicas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Dentro del proceso KDD, ¿qué elemento es el insumo inicial indispensable que se requiere antes de cualquier procesamiento?",
    "opciones": {
      "A": "El conocimiento descubierto.",
      "B": "Los datos.",
      "C": "El algoritmo de limpieza."
    },
    "respuesta_correcta": "B",
    "justificacion": "Lo primero que el proceso de KDD requiere es de los datos; es importante conocer los tipos y fuentes (dataset, raw data, database)."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Un científico de datos está analizando un conjunto de datos médicos para predecir el riesgo de diabetes. Utiliza un algoritmo que clasifica a un nuevo paciente basándose en la similitud con los \"k\" pacientes más parecidos en el histórico. ¿Qué algoritmo está empleando?",
    "opciones": {
      "A": "Árboles de Decisión.",
      "B": "K-Nearest Neighbors (K-NN).",
      "C": "Regresión Lineal."
    },
    "respuesta_correcta": "B",
    "justificacion": "El algoritmo K-Nearest Neighbors (K-vecinos más cercanos) es un método básico de aprendizaje automático utilizado para clasificación basado en cercanía/similitud."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "En el contexto de KDD, si se requiere descubrir grupos de clientes con comportamientos de compra similares sin tener etiquetas o categorías previas, ¿qué técnica es la más adecuada?",
    "opciones": {
      "A": "Clasificación.",
      "B": "Regresión.",
      "C": "Clustering."
    },
    "respuesta_correcta": "C",
    "justificacion": "El clustering es la tarea de minería de datos utilizada para agrupar datos sin clases predefinidas, a diferencia de la clasificación que requiere etiquetas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Para realizar una tarea de regresión compleja donde las relaciones entre variables no son lineales, ¿qué técnica de las siguientes es frecuentemente utilizada y compartida con tareas de clasificación?",
    "opciones": {
      "A": "K-Means.",
      "B": "Redes Neuronales.",
      "C": "Limpieza de datos."
    },
    "respuesta_correcta": "B",
    "justificacion": "Muchos métodos de clasificación, como las redes neuronales (Neural Networks) y el aprendizaje profundo (Deep Learning), se utilizan también para regresión y modelado complejo."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Después de aplicar algoritmos de minería de datos y obtener patrones, ¿cuál es la fase final crítica del proceso KDD que valida la utilidad del conocimiento?",
    "opciones": {
      "A": "Transformación.",
      "B": "Evaluación e interpretación.",
      "C": "Almacenamiento (Data Warehousing)."
    },
    "respuesta_correcta": "B",
    "justificacion": "La minería de datos es parte de un proceso mayor (KDD); tras la minería, es necesaria la fase de evaluación e interpretación para validar el conocimiento descubierto."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "El proceso de Descubrimiento de Conocimiento en Bases de Datos (KDD) implica varias etapas secuenciales. El orden lógico general es: Selección de datos, **_______**, Minería de Datos y Evaluación.",
    "opciones": {
      "A": "Visualización",
      "B": "Preprocesamiento y Transformación",
      "C": "Almacenamiento"
    },
    "respuesta_correcta": "B",
    "justificacion": "Después de elegir los datos, se realizan operaciones de preprocesamiento y transformación (limpieza, remoción de ruido) antes de la minería."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Los datos tal cual se obtienen de la fuente original, sin haber pasado por ningún proceso de limpieza o formateo, se conocen técnicamente como **_______**.",
    "opciones": {
      "A": "Datasets",
      "B": "Knowledge",
      "C": "Raw data"
    },
    "respuesta_correcta": "C",
    "justificacion": "Los datos crudos (_raw data_) son el insumo inicial antes de convertirse en un dataset procesado."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "La tarea de **_______** en minería de datos busca predecir un valor numérico continuo, a diferencia de la clasificación que predice una categoría discreta.",
    "opciones": {
      "A": "Regresión",
      "B": "Clustering",
      "C": "Asociación"
    },
    "respuesta_correcta": "A",
    "justificacion": "La regresión es una de las tareas más comunes en minería de datos, utilizada a menudo con métodos similares a la clasificación pero para valores continuos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Para garantizar la calidad de los resultados en la minería de datos, es necesario remover el **_______** y los datos faltantes durante la etapa de preprocesamiento.",
    "opciones": {
      "A": "Conocimiento",
      "B": "Ruido",
      "C": "Patrón"
    },
    "respuesta_correcta": "B",
    "justificacion": "El preprocesamiento incluye limpieza para remover ruido y outliers, así como manejar datos faltantes."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "La **_______** es una técnica de minería que puede utilizarse tanto para clasificación como para regresión, inspirada en el comportamiento biológico del cerebro humano.",
    "opciones": {
      "A": "Red Neuronal",
      "B": "Regla de Asociación",
      "C": "Distancia Euclidiana"
    },
    "respuesta_correcta": "A",
    "justificacion": "Las redes neuronales (_neural networks_) y el aprendizaje profundo (_deep learning_) son técnicas avanzadas mencionadas para tareas de clasificación y regresión."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Si un conjunto de datos contiene puntos que están muy alejados de la tendencia general, estos se denominan **_______** y su eliminación es crucial para evitar sesgos en modelos sensibles como la regresión lineal.",
    "opciones": {
      "A": "Centroides",
      "B": "Outliers",
      "C": "Nodos hoja"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los _outliers_ son puntos fuera de la mayoría de los datos que se deben remover durante el preprocesamiento para el buen funcionamiento de los modelos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "El proceso KDD no termina con la aplicación del algoritmo; la fase de **_______** es esencial para determinar si los patrones encontrados constituyen conocimiento válido y útil para el negocio.",
    "opciones": {
      "A": "Selección de datos",
      "B": "Interpretación y Evaluación",
      "C": "Limpieza de datos"
    },
    "respuesta_correcta": "B",
    "justificacion": "La evaluación e interpretación es la fase final donde se da sentido a los resultados de la minería."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione los conceptos de minería de datos con su descripción básica.\n**Conceptos**\n1. Dataset\n2. Raw Data\n3. KDD\n4. Preprocesamiento\n**Descripciones**\na) Datos en su estado original sin modificaciones.\nb) Proceso global de descubrimiento de conocimiento.\nc) Conjunto de datos seleccionado y estructurado.\nd) Etapa de limpieza y transformación de datos.\ne) Algoritmo de predicción numérica.",
    "opciones": {
      "A": "1c, 2a, 3b, 4d",
      "B": "1a, 2c, 3d, 4e",
      "C": "1c, 2e, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Dataset es el conjunto de datos. 2-a: Raw data son datos crudos. 3-b: KDD es el proceso completo de descubrimiento. 4-d: Preprocesamiento implica limpieza y transformación."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione las tareas de minería de datos con su objetivo.\n**Tareas**\n1. Clasificación\n2. Regresión\n3. Clustering\n**Objetivos**\na) Predecir un valor numérico continuo.\nb) Asignar datos a categorías predefinidas.\nc) Agrupar datos por similitud sin clases previas.\nd) Eliminar datos ruidosos.",
    "opciones": {
      "A": "1a, 2c, 3d",
      "B": "1b, 2a, 3c",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: Clasificación asigna categorías. 2-a: Regresión predice valores. 3-c: Clustering agrupa sin clases predefinidas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione las etapas del KDD con su función principal.\n**Etapas**\n1. Selección\n2. Transformación\n3. Minería de Datos\n4. Interpretación\n**Funciones**\na) Aplicación de algoritmos inteligentes para hallar patrones.\nb) Dar sentido y valor al patrón encontrado.\nc) Elegir los datos relevantes para el análisis.\nd) Adecuar los datos para el algoritmo (e.g., normalización).\ne) Almacenar los datos en discos.",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1e, 2a, 3c, 4d",
      "C": "1c, 2b, 3d, 4a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Selección de datos específicos. 2-d: Transformación y preprocesamiento. 3-a: Minería es la aplicación de algoritmos. 4-b: Interpretación valida el conocimiento."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione los problemas de datos con la técnica de preprocesamiento adecuada.\n**Problemas**\n1. Valores faltantes\n2. Ruido\n3. Outliers\n**Técnicas**\na) Remoción o suavizado.\nb) Imputación o eliminación de registros.\nc) Identificación y análisis/eliminación de puntos atípicos.\nd) Clasificación supervisada.",
    "opciones": {
      "A": "1b, 2a, 3c",
      "B": "1d, 2c, 3a",
      "C": "1a, 2b, 3d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: Datos faltantes se manejan con imputación. 2-a: Ruido se remueve o suaviza. 3-c: Outliers se identifican para análisis/eliminación."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione el tipo de dato con su característica.\n**Tipo**\n1. Raw Data\n2. Dataset\n3. Database\n**Característica**\na) Colección estructurada y persistente de datos.\nb) Conjunto de datos específico para un análisis.\nc) Datos crudos sin procesar.\nd) Algoritmo de limpieza.",
    "opciones": {
      "A": "1c, 2b, 3a",
      "B": "1a, 2c, 3b",
      "C": "1b, 2a, 3d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Raw data son datos crudos. 2-b: Dataset es el conjunto de datos para el problema. 3-a: Database es el sistema de almacenamiento base."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione el algoritmo con la tarea de minería para la cual es comúnmente utilizado, considerando las mejores prácticas.\n**Algoritmos**\n1. K-Nearest Neighbors\n2. K-Means (implícito en clustering)\n3. Deep Learning\n**Tareas/Usos**\na) Tareas complejas de clasificación y regresión (redes neuronales).\nb) Clasificación basada en la cercanía de instancias.\nc) Agrupamiento de datos no etiquetados (clustering).\nd) Limpieza de bases de datos.",
    "opciones": {
      "A": "1b, 2c, 3a",
      "B": "1a, 2b, 3c",
      "C": "1c, 2a, 3b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-b: K-NN se usa para clasificación por cercanía. 2-c: K-Means es el estándar para clustering. 3-a: Deep learning/Redes neuronales para tareas complejas."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione la fase del proceso KDD con el desafío técnico que resuelve.\n**Fase**\n1. Preprocesamiento\n2. Minería de Datos\n3. Evaluación\n**Desafío**\na) Selección del modelo matemático adecuado (ej. clasificación vs regresión).\nb) Calidad de datos (ruido, inconsistencia).\nc) Validez y utilidad del patrón en el contexto del negocio.\nd) Velocidad de transferencia de red.",
    "opciones": {
      "A": "1d, 2a, 3b",
      "B": "1b, 2a, 3c",
      "C": "1c, 2b, 3a"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: Preprocesamiento ataca la calidad (ruido). 2-a: Minería implica elegir la tarea/algoritmo (clasificación/regresión). 3-c: Evaluación determina la validez del conocimiento."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Relacione los términos técnicos con su función en el aprendizaje automático.\n**Término**\n1. Training Set (implícito)\n2. Outlier removal\n3. Classification Model\n**Función**\na) Mejorar la precisión del modelo eliminando datos atípicos.\nb) Asignar nuevas instancias a clases conocidas.\nc) Conjunto de datos usado para construir el modelo.\nd) Almacenar datos históricos.",
    "opciones": {
      "A": "1c, 2a, 3b",
      "B": "1a, 2b, 3c",
      "C": "1b, 2c, 3a"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Training set es la base para aprender. 2-a: Remover outliers mejora el modelo. 3-b: Modelo de clasificación asigna clases."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Minería de Datos",
    "pregunta": "Un sistema de diagnóstico médico inteligente debe procesar historiales clínicos (texto y números) para detectar pacientes con riesgo alto de enfermedad cardíaca. Relacione los componentes del sistema con su implementación técnica correcta en el flujo KDD.\n**Componente**\n1. Datos de entrada\n2. Preparación\n3. Modelado\n4. Validación\n**Implementación**\na) Algoritmo de Red Neuronal o K-NN para clasificar riesgo.\nb) Raw data proveniente de expedientes clínicos y sensores.\nc) Limpieza de valores nulos y normalización de edades.\nd) Interpretación de resultados por especialistas médicos.\ne) Creación de base de datos SQL.",
    "opciones": {
      "A": "1e, 2c, 3a, 4b",
      "B": "1b, 2c, 3a, 4d",
      "C": "1b, 2a, 3d, 4c"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-b: Datos de entrada son Raw data. 2-c: Preparación es preprocesamiento (limpieza). 3-a: Modelado es la minería usando algoritmos. 4-d: Validación es la fase de evaluación e interpretación."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "¿Cuál es la característica principal que diferencia a un Sistema Operativo Distribuido de un Sistema Operativo de Red?",
    "opciones": {
      "A": "La capacidad de conectar computadoras de diferentes fabricantes.",
      "B": "La percepción de un sistema único y coherente por parte del usuario, ocultando la multiplicidad de máquinas.",
      "C": "La utilización de un servidor centralizado de archivos para almacenar datos de todos los usuarios."
    },
    "respuesta_correcta": "B",
    "justificacion": "Un sistema distribuido se define por la transparencia, dando la percepción de un sistema único y coherente, lo que no ocurre en un SO de red."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En la clasificación de hardware para sistemas distribuidos, ¿qué distingue a un multiprocesador de una multicomputadora?",
    "opciones": {
      "A": "Los multiprocesadores tienen memoria compartida accesible por todas las CPUs, mientras que las multicomputadoras tienen memoria privada.",
      "B": "Los multiprocesadores utilizan un bus para comunicación, mientras que las multicomputadoras siempre usan conmutadores.",
      "C": "Los multiprocesadores están limitados a una sola CPU, mientras que las multicomputadoras tienen múltiples CPUs."
    },
    "respuesta_correcta": "A",
    "justificacion": "La distinción fundamental establecida por Tanenbaum es que en los multiprocesadores existe un único espacio de direcciones compartido por todas las CPUs, mientras que en las multicomputadoras cada CPU tiene su propia memoria local y privada."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "¿Cuál es el objetivo principal del uso de \"middleware\" en sistemas distribuidos?",
    "opciones": {
      "A": "Gestionar directamente el hardware de red y los controladores de dispositivos.",
      "B": "Proporcionar una capa de software que ofrezca uniformidad y oculte la heterogeneidad de los sistemas operativos subyacentes.",
      "C": "Incrementar la velocidad del reloj de los procesadores distribuidos."
    },
    "respuesta_correcta": "B",
    "justificacion": "El middleware se sitúa entre el sistema operativo y las aplicaciones para proporcionar un nivel de abstracción que facilita la comunicación y gestión de recursos en entornos heterogéneos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En el contexto de RPC (Llamada a Procedimiento Remoto), ¿cuál es la función del \"resguardo del cliente\" (client stub)?",
    "opciones": {
      "A": "Ejecutar el procedimiento real en el servidor y devolver el resultado.",
      "B": "Empaquetar los parámetros en un mensaje y enviarlo al núcleo para su transmisión.",
      "C": "Gestionar la base de datos de localización de servicios de la red."
    },
    "respuesta_correcta": "B",
    "justificacion": "El resguardo del cliente (client stub) se encarga del \"marshaling\" o empaquetado: toma los parámetros de la llamada, los empaqueta en un mensaje y solicita al núcleo que lo envíe al servidor, ocultando los detalles de red al programa cliente."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En un sistema distribuido, se desea implementar tolerancia a fallas mediante \"réplica activa\". ¿Qué implica esta estrategia?",
    "opciones": {
      "A": "Se realiza una copia de seguridad de los datos periódicamente en un servidor secundario inactivo.",
      "B": "Todos los procesadores réplica ejecutan las mismas instrucciones simultáneamente y se comparan sus resultados.",
      "C": "Un procesador primario ejecuta la tarea y, solo si falla, el estado se transfiere a un respaldo."
    },
    "respuesta_correcta": "B",
    "justificacion": "La réplica activa implica que todos los servidores (réplicas) están activos y procesan la misma solicitud al mismo tiempo. Esto permite enmascarar fallas de manera instantánea, a diferencia del respaldo primario."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Al diseñar un micronúcleo para un sistema distribuido, ¿qué servicios deben permanecer estrictamente dentro del modo núcleo (kernel mode)?",
    "opciones": {
      "A": "El sistema de archivos, el manejo de directorios y la gestión de procesos completa.",
      "B": "La comunicación entre procesos (IPC), gestión básica de memoria y planificación de bajo nivel.",
      "C": "Todos los servicios del sistema operativo para garantizar la máxima velocidad."
    },
    "respuesta_correcta": "B",
    "justificacion": "La filosofía del micronúcleo es minimizar el código en modo núcleo. Solo los servicios esenciales como IPC, memoria básica y manejo de interrupciones/planificación básica se mantienen en el núcleo."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En el algoritmo de sincronización de relojes de Lamport, ¿qué sucede si un proceso recibe un mensaje con una marca de tiempo $T$ mayor que su reloj local $C$?",
    "opciones": {
      "A": "El proceso descarta el mensaje por considerarlo un error futuro.",
      "B": "El proceso ajusta su reloj local a $C = T + 1$.",
      "C": "El proceso detiene su reloj hasta que el tiempo real alcance a $T$."
    },
    "respuesta_correcta": "B",
    "justificacion": "Según el algoritmo de Lamport, si un mensaje llega con un tiempo mayor, el receptor debe adelantar su reloj a $C = T + 1$ para mantener la consistencia lógica (relación \"ocurre antes de\")."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Para lograr una semántica de \"ejecución exacta de una vez\" en una RPC ante la pérdida de mensajes de respuesta, ¿qué mecanismo es necesario?",
    "opciones": {
      "A": "Simplemente retransmitir la solicitud hasta recibir respuesta.",
      "B": "El servidor debe filtrar duplicados y el cliente debe usar números de secuencia en las solicitudes.",
      "C": "Utilizar exclusivamente el protocolo TCP en lugar de UDP."
    },
    "respuesta_correcta": "B",
    "justificacion": "Si se pierden respuestas, el cliente retransmite. El servidor debe detectar duplicados (mediante números de secuencia) para no ejecutar dos veces operaciones no idempotentes, garantizando la semántica de \"ejecución exacta de una vez\"."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En un sistema de **multiprocesadores con base en buses**, la principal limitación para escalar el sistema es **_______**, que ocurre cuando muchas CPUs intentan acceder a la memoria global simultáneamente. Para mitigar esto, se añaden **_______** a cada CPU.",
    "opciones": {
      "A": "la latencia de red / discos duros",
      "B": "la saturación del bus / memorias caché",
      "C": "el fallo de energía / baterías de respaldo"
    },
    "respuesta_correcta": "B",
    "justificacion": "En arquitecturas basadas en bus, el bus es un cuello de botella (saturación). Las memorias caché locales reducen el tráfico en el bus."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Un **_______** es un programa en ejecución que posee un espacio de direcciones y recursos, mientras que un **_______** es una unidad de ejecución ligera dentro de aquel, que comparte el mismo espacio de direcciones.",
    "opciones": {
      "A": "hilo / proceso",
      "B": "proceso / hilo",
      "C": "servidor / cliente"
    },
    "respuesta_correcta": "B",
    "justificacion": "Definición estándar de proceso como contenedor de recursos y el hilo como la entidad que se planifica para ejecución dentro del proceso."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "La **_______** es la propiedad de un sistema distribuido que permite ocultar al usuario que los recursos y procesos están físicamente separados. Un ejemplo es la **_______**, que oculta el lugar geográfico donde se encuentra un recurso.",
    "opciones": {
      "A": "Transparencia / Transparencia de localización",
      "B": "Flexibilidad / Transparencia de réplica",
      "C": "Confiabilidad / Transparencia de concurrencia"
    },
    "respuesta_correcta": "A",
    "justificacion": "La transparencia es el concepto clave de ocultar la distribución. La transparencia de localización específicamente oculta dónde está el recurso."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "El software que gestiona la comunicación y el intercambio de datos entre componentes distribuidos, actuando como un enlace entre el sistema operativo y las aplicaciones, se denomina **_______**.",
    "opciones": {
      "A": "Firmware",
      "B": "Middleware",
      "C": "Shareware"
    },
    "respuesta_correcta": "B",
    "justificacion": "El middleware es la capa de software que proporciona servicios comunes y transparencia a las aplicaciones en un sistema distribuido."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En el contexto de la sincronización distribuida, la condición de **_______** es necesaria para evitar que dos procesos accedan simultáneamente a un recurso compartido. El algoritmo de **_______** utiliza un token o testigo que circula en un anillo lógico para garantizar esta condición.",
    "opciones": {
      "A": "Interbloqueo / Ricart y Agrawala",
      "B": "Exclusión mutua / Paso de testigo (token ring)",
      "C": "Consistencia / Lamport"
    },
    "respuesta_correcta": "B",
    "justificacion": "La exclusión mutua previene condiciones de carrera. El algoritmo de anillo (token ring) pasa un mensaje especial (token); solo quien tiene el token puede entrar a la sección crítica."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Para implementar tolerancia a fallas mediante **_______**, se utilizan componentes físicos adicionales (como procesadores extra). En cambio, la **_______** utiliza bits extra para detección y corrección de errores en los datos.",
    "opciones": {
      "A": "redundancia de tiempo / redundancia de información",
      "B": "redundancia de hardware / redundancia de información",
      "C": "redundancia de software / redundancia de tiempo"
    },
    "respuesta_correcta": "B",
    "justificacion": "La redundancia de hardware utiliza componentes físicos adicionales. La redundancia de información utiliza bits extra (como códigos ECC) para detección y corrección de errores."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En un sistema de archivos distribuido como NFS, el protocolo de montaje devuelve un **_______** al cliente, el cual contiene información como el inodo y se utiliza en llamadas posteriores para leer o escribir archivos.",
    "opciones": {
      "A": "descriptor de archivo (file descriptor)",
      "B": "manejador de archivo (file handle)",
      "C": "bloque de control de proceso (PCB)"
    },
    "respuesta_correcta": "B",
    "justificacion": "En NFS, el servidor devuelve un \"file handle\" (manejador de archivo) que identifica el archivo de manera única y opaca para el cliente."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "El modelo de **_______** describe un sistema donde las solicitudes de los clientes se distribuyen entre varios servidores para evitar cuellos de botella, a menudo utilizando un mecanismo de **_______**.",
    "opciones": {
      "A": "cliente-servidor / paginación",
      "B": "clúster / balanceo de carga",
      "C": "mainframe / tiempo compartido"
    },
    "respuesta_correcta": "B",
    "justificacion": "Los clústeres utilizan múltiples servidores para trabajar juntos y el balanceo de carga es la técnica para distribuir el trabajo equitativamente entre ellos."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione el tipo de transparencia en sistemas distribuidos con su descripción correcta.\n**[Tipos de Transparencia]**\n1. De Localización\n2. De Migración\n3. De Réplica\n4. De Concurrencia\n**[Descripciones]**\na) Oculta que un recurso se mueva a otra ubicación.\nb) Oculta que varios usuarios compartan recursos.\nc) Oculta dónde se encuentra exactamente un recurso.\nd) Oculta que existen múltiples copias de un recurso.",
    "opciones": {
      "A": "1c, 2a, 3d, 4b",
      "B": "1a, 2c, 3b, 4d",
      "C": "1d, 2b, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Localización oculta el \"dónde\". 2-a: Migración permite mover el recurso sin que el usuario lo note. 3-d: Réplica oculta que hay copias redundantes. 4-b: Concurrencia gestiona el acceso simultáneo de usuarios."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione la arquitectura de hardware con su característica distintiva.\n**[Arquitectura]**\n1. Multiprocesador en base a bus\n2. Multicomputadora homogénea\n3. Multiprocesador con conmutador\n4. Multicomputadora heterogénea\n**[Característica]**\na) Memoria compartida, usa red de conmutación (ej. Omega) para conectar CPUs y memoria.\nb) Memoria privada, utiliza la misma plataforma de hardware/software en todos los nodos.\nc) Memoria compartida, limitado por el ancho de banda del medio de comunicación central.\nd) Memoria privada, nodos con diferente hardware o sistemas operativos.",
    "opciones": {
      "A": "1b, 2d, 3a, 4c",
      "B": "1c, 2b, 3a, 4d",
      "C": "1a, 2c, 3d, 4b"
    },
    "respuesta_correcta": "B",
    "justificacion": "1-c: Bus limita escalabilidad en memoria compartida. 2-b: Multicomputadora (memoria privada) homogénea (iguales). 3-a: Conmutador permite escalar memoria compartida. 4-d: Heterogénea implica sistemas diferentes."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione el concepto de proceso/hilo con su definición.\n**[Concepto]**\n1. Hilo (Thread)\n2. Proceso\n3. Hilo a nivel de usuario\n4. Hilo a nivel de núcleo\n**[Definición]**\na) Entidad que agrupa recursos y un espacio de direcciones.\nb) Gestionado por el SO, más costoso de crear pero mejor concurrencia.\nc) Flujo de control dentro de un proceso, comparte memoria.\nd) Gestionado por librería, rápido de crear, bloqueo afecta a todo el proceso.",
    "opciones": {
      "A": "1c, 2a, 3d, 4b",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2c, 3a, 4d"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Hilo (Flujo de control). 2-a: Proceso (Agrupa recursos). 3-d: Hilo usuario (Rápido, bloqueo afecta al proceso). 4-b: Hilo núcleo (Gestionado por SO, mejor concurrencia)."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione los pasos de una RPC (Llamada a Procedimiento Remoto) con su orden lógico.\n**[Pasos]**\n1. El resguardo del cliente empaqueta los parámetros.\n2. El cliente llama al resguardo del cliente (client stub).\n3. El núcleo envía el mensaje al servidor.\n4. El resguardo del cliente pasa el mensaje al núcleo local.",
    "opciones": {
      "A": "1b, 2a, 3d, 4c",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "El orden correcto es: El cliente llama al stub (2-b) $\\to$ El stub empaqueta (1-a) $\\to$ El stub pasa al núcleo (4-d) $\\to$ El núcleo envía (3-c). El orden es 2 $\to$ 1 $\to$ 4 $\to$ 3. De las opciones, la que respeta la secuencia dada es la A (1b, 2a, 3d, 4c), asumiendo que las letras en el conjunto B se refieren a los pasos. Reevaluando la pregunta: si el orden es 1, 2, 3, 4 y se deben relacionar con un orden lógico, la opción A no tiene sentido. Usando la secuencia lógica: 2-cliente llama $\to$ 1-stub empaqueta $\to$ 4-stub pasa $\to$ 3-núcleo envía."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione el tipo de sistema operativo con su descripción.\n**[Tipo de SO]**\n1. Sistema Monolítico\n2. Sistema de Red\n3. Sistema Distribuido\n4. Micronúcleo\n**[Descripción]**\na) Colección de máquinas independientes que actúan como una sola.\nb) Kernel básico con servicios ejecutándose como procesos de usuario.\nc) Todo el SO corre en un único espacio de direcciones en modo kernel.\nd) Máquinas independientes donde el usuario gestiona explícitamente las conexiones.",
    "opciones": {
      "A": "1c, 2d, 3a, 4b",
      "B": "1a, 2b, 3c, 4d",
      "C": "1d, 2a, 3b, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Monolítico (todo en kernel). 2-d: Red (gestión explícita). 3-a: Distribuido (imagen única). 4-b: Micronúcleo (servicios mínimos)."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione la estrategia de asignación de procesadores con su mecanismo.\n**[Estrategia]**\n1. Determinística\n2. Heurística\n3. Distribuida\n4. Centralizada\n**[Mecanismo]**\na) Un solo nodo toma todas las decisiones de asignación.\nb) Se basa en reglas prácticas para encontrar una solución buena (no óptima).\nc) Utiliza un algoritmo matemático exacto basado en grafos estáticos.\nd) Las decisiones se toman cooperativamente entre múltiples nodos.",
    "opciones": {
      "A": "1c, 2b, 3d, 4a",
      "B": "1a, 2c, 3b, 4d",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Determinística usa grafos estáticos. 2-b: Heurística usa reglas prácticas. 3-d: Distribuida toma decisiones cooperativas. 4-a: Centralizada concentra la decisión."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione el problema de RPC con su solución o semántica.\n**[Problema RPC]**\n1. Cliente no localiza al servidor\n2. Pérdida de mensaje de solicitud\n3. Pérdida de mensaje de respuesta\n4. Caída del servidor tras ejecución\n**[Solución/Semántica]**\na) Temporizador y retransmisión.\nb) Números de secuencia para detectar duplicados.\nc) Excepción o señal al cliente.\nd) Semántica \"al menos una vez\" o \"exactamente una vez\" (idempotencia).",
    "opciones": {
      "A": "1c, 2a, 3b, 4d",
      "B": "1a, 2b, 3c, 4d",
      "C": "1d, 2c, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: Si el servidor no está, el stub del cliente lanza excepción. 2-a: Si la solicitud se pierde, el cliente usa timeout y reenvía. 3-b: Si la respuesta se pierde, el servidor usa números de secuencia para no re-ejecutar, solo re-responder. 4-d: Si el servidor cae, garantizar semántica exacta es difícil."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "Relacione el modelo de consistencia con su definición.\n**[Modelo]**\n1. Consistencia Estricta\n2. Consistencia Secuencial\n3. Consistencia Causal\n4. Consistencia Débil\n**[Definición]**\na) Cualquier lectura a una variable x devuelve el valor de la escritura más reciente en tiempo real.\nb) Las escrituras relacionadas potencialmente por causa-efecto son vistas en el mismo orden por todos.\nc) El resultado de una ejecución es el mismo que si las operaciones de todos los procesadores se ejecutaran en algún orden secuencial.\nd) La consistencia solo se garantiza al entrar o salir de una sección crítica (variable de sincronización).",
    "opciones": {
      "A": "1a, 2c, 3b, 4d",
      "B": "1b, 2a, 3d, 4c",
      "C": "1c, 2d, 3a, 4b"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-a: Estricta = tiempo real absoluto. 2-c: Secuencial = orden entrelazado válido. 3-b: Causal = respeta causalidad de Lamport. 4-d: Débil = sincronización explícita."
  },
  {
    "tema": "Soluciones de Cómputo Inteligente - Cómputo Distribuido",
    "pregunta": "En un sistema de **cómputo distribuido tolerante a fallas**, se implementa un sistema de archivos replicado. Relacione los conceptos de arquitectura, comunicación y fallas para lograr una operación correcta.\n**[Elemento del Sistema]**\n1. Grupo de servidores con **Réplica Activa**\n2. Comunicación vía **Multicast** atómico\n3. Protocolo de **Sincronización de Relojes**\n4. **Votación**\n**[Función en el Diseño]**\na) Garantiza que todos los servidores reciban las solicitudes de actualización en el mismo orden o ninguno la reciba.\nb) Permite enmascarar fallas bizantinas si $3k+1$ procesadores están presentes.\nc) Permite que el sistema siga operando instantáneamente ante la caída de un nodo sin pérdida de estado.\nd) Necesario para asegurar que las marcas de tiempo de los archivos sean consistentes entre nodos.",
    "opciones": {
      "A": "1c, 2a, 3d, 4b",
      "B": "1a, 2b, 3c, 4d",
      "C": "1b, 2d, 3a, 4c"
    },
    "respuesta_correcta": "A",
    "justificacion": "1-c: La réplica activa permite recuperación instantánea. 2-a: El multicast atómico asegura el mismo orden de actualización en todas las réplicas. 3-d: La sincronización de relojes asegura consistencia de marcas de tiempo en archivos. 4-b: La votación se usa en tolerancia a fallas Bizantinas."
  }
]
